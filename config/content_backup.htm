<h1>About</h1>
<p>課程名稱: 計算機程式</p>
<p>Github 倉儲: <a href="https://github.com/mdecycu/cp2025">https://github.com/mdecycu/cp2025</a></p>
<p>課程網頁: <a href="https://mde.tw/cp2025">https://mde.tw/cp2025</a> (cp for computer programming)</p>
<p>分組示範網站: <a href="https://mde.tw/cp_demo">https://mde.tw/cp_demo</a> </p>
<p>w14-w18: Python (Flask)，Brython，Peewee (ORM)，SQLite</p>
<p style="padding-left: 30px;">Brython 程式環境: </p>
<p style="padding-left: 60px;"><a href="https://s5.eng.nfu.edu.tw:9499/">https://s5.eng.nfu.edu.tw:9499/</a> (部署到 Linux)</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecycu/brython_proj">https://github.com/mdecycu/brython_proj</a> (原始碼)</p>
<p style="padding-left: 30px;">英雄榜: </p>
<p style="padding-left: 60px;"><a href="https://s5.eng.nfu.edu.tw:9498/">https://s5.eng.nfu.edu.tw:9498/</a> (部署到 Linux)</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecycu/cp_final_ex">https://github.com/mdecycu/cp_final_ex</a> (原始碼)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-032-09008-9">Let's Talk AI</a></p>
<p>課程簡介:</p>
<p style="padding-left: 30px;">cp2025 課程將以每組至多六人分組進行，從導入瀏覽器中的 <a href="https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot.py">brython_robot.py</a> 2D 機器人模組為開端，讓學員將基本的 <a href="https://mde.tw/cp2025/content/Robot_ex.html">Python 程式範例</a>，存入個人 Github 帳號中的 <a href="https://gist.github.com/">Gist</a> 倉儲後，直接在 <a href="https://mde.tw/cp2025/content/Brython.html">Brython 頁面</a>中進行練習。</p>
<p style="padding-left: 30px;">此外，每位學員可利用 <a href="https://github.com/features/codespaces">Github Codespaces</a> 或近端可攜系統，維護個人網頁或利用 git 分散式版次管理系統，與組員協同開發程式。</p>
<p style="padding-left: 30px;">課程最後將利用瀏覽器中的 <a href="https://webots.cloud/AcTNYs0">3D 機器人動態模擬</a>，說明 Python 程式如何應用於雲端系統上的機電控制系統設計。</p>
<p>可攜程式套件:</p>
<p style="padding-left: 30px;"><a href="http://229.cycu.org/portable_2026.7z">portable_2026.7z</a> (387MB)</p>
<p style="padding-left: 60px;">解開壓縮後，雙點擊 start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。</p>
<p style="padding-left: 60px;">可攜系統啟動後，在命令列執行 <span style="background-color: #ccffcc;">conda activate y:\envs\cmsimde</span> 可進入能執行 CMSiMDE 的環境。</p>
<p style="padding-left: 60px;">若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\Scripts\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\Scripts\activate.bat" %Disk%:\envs\cmsimde。</p>
<p>課程內容:</p>
<p style="padding-left: 30px;">如何維持教室整齊清潔?</p>
<p style="padding-left: 60px;">學員定期打掃 (由助教安排) </p>
<p style="padding-left: 60px;">學員自律</p>
<p style="padding-left: 30px;">如何善用教室與工作站室硬體?</p>
<p style="padding-left: 60px;">電腦設定</p>
<p style="padding-left: 60px;">網路連線</p>
<p style="padding-left: 60px;">課餘時間預約 (由助教安排) </p>
<p style="padding-left: 30px;">Python 與 Javascript 程式語法在 <a href="https://mde.tw/cp2025/reeborg">Reeborg</a> 機器人系統上的應用。</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecycu/python_2025/blob/main/%E7%AC%AC01%E8%AA%B2%EF%BC%9A%E5%88%9D%E8%AD%98Python.md">Python 程式教材</a></p>
<p style="padding-left: 30px;">利用 Git 與 Github 建立分組網站。</p>
<p>Teams 線上教學:</p>
<p style="padding-left: 30px;">以 "學號@nfu.edu.tw" 登入<span> </span><a href="https://login.microsoftonline.com/">https://login.microsoftonline.com/</a><span> </span>Office 365</p>
<p style="padding-left: 30px;">MS Teams 團隊代碼: w87x8do  </p>
<p>課程評分:</p>
<p style="padding-left: 30px;"><span style="background-color: #ffff00;">學習心得報告 (60%)</span> - MS Teams 線上參與，<span style="background-color: #ccffcc;">6人一組</span>每三週發表學習心得。</p>
<p style="padding-left: 60px;">w3、w7、w10、w14、w17、w18</p>
<p style="padding-left: 60px;">學習心得報告主題:</p>
<p style="padding-left: 60px;">w3: 什麼是 git, GitHub, gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？ (<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/b4134dc3724f9c6aa1de7534a74f298288de0fa5/round_dot_move.py">動態模擬</a>)</p>
<p style="padding-left: 60px;">w7: Brython 是什麼？如何在瀏覽器配置 Brython 環境？ Brython 能做什麼？ (<a href="https://mde.tw/cp2025/content/Brython.html">Brython</a>, <a href="https://mde.tw/cp2025/content/Robot_ex.html">Examples</a>)</p>
<p style="padding-left: 60px;">w10: 如何在瀏覽器中模擬機器人作動？ (<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">機器人作動</a>)</p>
<p style="padding-left: 60px;">w14: 在瀏覽器中模擬機器人作動的目的是什麼？ (<a href="/downloads/otto_robot.7z">otto_robot.7z</a>, <a href="https://mde.tw/cad2025/content/Homework.html">Plotter</a>, <a href="/downloads/open_duck_mini.7z">open_duck_mini.7z</a> ,<a href="https://webots.cloud/AcTNYs0">https://webots.cloud/AcTNYs0</a>)</p>
<p style="padding-left: 60px;">w17 (<span style="background-color: #ccffcc;">1b 採 Youtube 影片簡報</span>): 計算機程式課程學到了什麼？</p>
<p style="padding-left: 60px;">w18: 課程總結</p>
<p style="padding-left: 30px;"><span style="background-color: #ffff00;">個人與分組網站維護 (40%)</span> - 每週至少兩次推送與課程進度相關的學習內容與心得。</p>
<p style="padding-left: 60px;">w9 期中自評、w18 期末自評</p>
<p>行事曆</p>
<p style="padding-left: 30px;">1a 上課時段: 每週三 13:20 - 16:10</p>
<p style="padding-left: 30px;">1b 上課時段: 每週四 09:10 - 12:00 (w16 12/25 行憲放假, w17 1/1 元旦放假)</p>
<p><a href="https://calendar.google.com/calendar/embed?src=mde.nfu.edu.tw_3439313938333136353439%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;mode=week&amp;src=mde.nfu.edu.tw_35303530373431313438%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;src=yen%40gm.nfu.edu.tw&amp;ctz=Asia%2FTaipei"> 全頁檢視 </a></p>
<p><iframe height="600" src="https://calendar.google.com/calendar/embed?src=mde.nfu.edu.tw_3439313938333136353439%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;mode=week&amp;src=mde.nfu.edu.tw_35303530373431313438%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;src=yen%40gm.nfu.edu.tw&amp;ctz=Asia%2FTaipei" width="800"></iframe></p><h2>cs101</h2>
<p>Python 之所以成為全球最受歡迎的程式語言之一，有很多原因，涵蓋語言本身的設計哲學、社群支持、應用廣度等方面。以下是最主要的幾個原因：</p>
<h4>1. 語法簡潔易讀</h4>
<p style="padding-left: 30px;">Python 的語法設計非常接近英文，自然語言風格讓初學者也能輕鬆學會。</p>
<p style="padding-left: 30px;">沒有大括號 {}，用縮排代表程式區塊，強迫良好的程式風格。</p>
<h4>2. 用途廣泛</h4>
<p>Python 幾乎無所不能，應用領域包括：</p>
<p style="padding-left: 30px;">資料分析與科學運算（NumPy、Pandas、Matplotlib）</p>
<p style="padding-left: 30px;">機器學習與人工智慧（TensorFlow、PyTorch、Scikit-learn）</p>
<p style="padding-left: 30px;">Web 開發（Django、Flask、FastAPI）</p>
<p style="padding-left: 30px;">自動化控制程式編寫</p>
<p style="padding-left: 30px;">網路爬蟲</p>
<p style="padding-left: 30px;">桌面與GUI應用程式</p>
<p style="padding-left: 30px;">遊戲開發（如 Pygame）<br/><br/>DevOps / 系統管理工具</p>
<h4>3. 龐大且活躍的開發者社群</h4>
<p style="padding-left: 30px;">有問題很容易找到答案（Stack Overflow、Reddit、官方論壇等）</p>
<p style="padding-left: 30px;">有大量教學、書籍、影片課程</p>
<p style="padding-left: 30px;">開源庫與第三方模組極多（PyPI 上超過 30 萬個套件）</p>
<h4>4. 跨平台支援</h4>
<p style="padding-left: 30px;">Python 可在 Windows、macOS、Linux 執行</p>
<p style="padding-left: 30px;">幾乎所有主流作業系統都內建或能安裝 Python</p>
<h4>5. 與其他語言整合性高</h4>
<p style="padding-left: 30px;">可以與 C/C++、Java、R 等語言互通</p>
<p style="padding-left: 30px;">支援呼叫 C 擴充模組，提高效能</p>
<p style="padding-left: 30px;">常作為「膠水語言」：連接不同系統、程式或模組</p>
<h4>6. 適合快速開發與原型設計</h4>
<p style="padding-left: 30px;">由於語法簡潔、庫資源多，Python 非常適合快速構建原型</p>
<p style="padding-left: 30px;">初創公司、研究人員常用它來試驗想法，後期再轉向高效能語言</p>
<h4>7. 廣泛的企業與學術支持</h4>
<p style="padding-left: 30px;">Google、Netflix、Spotify、Dropbox、NASA 等都大量使用 Python</p>
<p style="padding-left: 30px;">許多大學將 Python 作為入門編程語言（取代 C++ 或 Java）</p>
<h4>8. 強大的標準函式庫</h4>
<p style="padding-left: 30px;">Python 內建很多實用模組（處理檔案、網路、壓縮、日期、JSON 等）</p>
<p style="padding-left: 30px;">範圍涵蓋日常開發所需，降低開發成本</p>
<hr/>
<p><a href="https://github.com/mdecycu/python_2025">https://github.com/mdecycu/python_2025</a> (第1 ~ 19 課內容為繁體中文)</p>
<p><a href="https://people.eecs.berkeley.edu/~ddgarcia/papers/2016-11-29-Party-With-Thousands-The-Most-Popular-Programming-Courses.pdf">最受歡迎的程式課</a> (<a href="/downloads/最受歡迎的程式課.pdf">pdf</a>)</p>
<p><a href="https://cs61a.org/">https://cs61a.org/</a> Structure and Interpretation of Computer Programs</p>
<p style="padding-left: 30px;"><a href="/downloads/61a-fa23-final.pdf">61a-fa23-final.pdf</a> (2023 秋季)</p>
<p style="padding-left: 60px;"><a href="/downloads/61a-fa23-mt1.pdf">61a-fa23-mt1.pdf</a>    <a href="/downloads/61a-fa23-mt2.pdf">61a-fa23-mt2.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/61a-sp24-final.pdf">61a-sp24-final.pdf</a> (2024 春季)</p>
<p style="padding-left: 60px;"><a href="/downloads/61a-sp24-mt1.pdf">61a-sp24-mt1.pdf</a>    <a href="/downloads/61a-sp24-mt2.pdf">61a-sp24-mt2.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/61a-su24-final.pdf">61a-su24-final.pdf</a> (2024 暑季)</p>
<p style="padding-left: 60px;"><a href="/downloads/61a-su24-midterm.pdf">61a-su24-midterm.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/61a-fa24-final.pdf">61a-fa24-final.pdf</a> (2024 秋季)</p>
<p style="padding-left: 60px;"><a href="/downloads/61a-fa24-mt1.pdf">61a-fa24-mt1.pdf</a>    <a href="/downloads/61a-fa24-mt2.pdf">61a-fa24-mt2.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/61a-sp25-final.pdf">61a-sp25-final.pdf</a> (2025 春季)</p>
<p style="padding-left: 60px;"><a href="/downloads/61a-sp25-mt1.pdf">61a-sp25-mt1.pdf</a>    <a href="/downloads/61a-sp25-mt2.pdf">61a-sp25-mt2.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/61a-su25-final.pdf">61a-su25-final.pdf</a> (2025 暑季)</p>
<p style="padding-left: 60px;"><a href="/downloads/61a-su25-midterm.pdf">61a-su25-midterm.pdf</a></p>
<p style="padding-left: 30px;"><a href="https://www.composingprograms.com/">https://www.composingprograms.com/</a> (<a href="/downloads/composing_programs.pdf">composing_programs.pdf</a>, 2019 version, <a href="https://composingprograms.netlify.app/">簡體中文翻譯</a>)</p>
<p><a href="https://mde.tw/cs101">https://mde.tw/cs101</a> </p>
<h2>Computer</h2>
<p>一、假如使用 Windows 操作系統</p>
<p><span style="background-color: #ccffcc;">顯示副檔名與隱藏檔</span></p>
<p style="padding-left: 30px;">檔案總管內定並無檢視副檔名與隱藏檔案的設定，若之後所使用的工具並非安裝版，其副檔名並未登錄於操作系統，因此可能無法透過檔案 icon 辨識檔案屬性，最直接的方式就是透過副檔名確認。</p>
<p style="padding-left: 30px;">其次，許多系統工具會使用 Windows 認定的隱藏檔格式 (以 . 開頭)，這些隱藏檔案或隱藏目錄，在 Git 指令操作時非常重要，因此建議將 Windows 檔案總管視窗下的檢視設定中，開啟檢視附檔名與隱藏檔的選項設定。</p>
<p>假如使用 Windows 11 家用版</p>
<p style="padding-left: 30px;">家用版與專業版的差異:</p>
<p style="padding-left: 60px;">家用版僅支援單一 CPU</p>
<p style="padding-left: 60px;">家用版最多支援 128 GB 記憶體</p>
<p style="padding-left: 60px;">家用版無硬碟編碼功能</p>
<p style="padding-left: 60px;">家用版無 <a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-isolation/windows-sandbox/">Windows Sandbox</a></p>
<p style="padding-left: 60px;">家用版無 Remote Desk Top Host - 可以使用 <a href="https://en.wikipedia.org/wiki/VNC">VNC</a> 進行遠端控制 </p>
<p style="padding-left: 60px;">家用版必須自行安裝 Group Policy Editor (gpedit.msc) - 但可以<a href="https://www.itechtics.com/easily-enable-group-policy-editor-gpedit-msc-in-windows-10-home-edition/">自行配置安裝</a></p>
<p style="padding-left: 60px;">家用版無 Hyper-V - 可以使用 <a href="https://www.virtualbox.org/wiki/Download_Old_Builds_6_1">Virtualbox</a> 配置虛擬機</p>
<p>無登入狀態使用 Windows 11</p>
<p style="padding-left: 30px;">新機開啟之後的設定流程，系統要求必須登入微軟帳號才能繼續使用時，可以透過指令輸入，在重新開機設定階段，繞過此一過程。</p>
<p style="padding-left: 30px;">意即，當按下 Shift + F10 (若有 Fn 鍵則需按下 Shift + Fn + F10) 時，系統會跳出命令列視窗，若此時命令列視窗中的目錄，已經跳到 C:\Windows\System32&gt;，則可利用 cd OOBE 之後執行 BYPASSNRO，要求重新開機時繞過此一要求。</p>
<p style="padding-left: 30px;">這些指令都是英文字母，OOBE 是 Out Of Box Experience 的縮寫，而 BYPASSNRO 則是 BYPASS Network Requirement Out-of-box 的意思。</p>
<p style="padding-left: 30px;">在 Windows 11 設置過程，選擇執行 C:\Windows\System32\OOBE\BYPASSNRO 按下 Enter，就會重新開機，之後的設置過程，便會繞過需要登入微軟帳號才能使用 Windows 11 的要求。</p>
<p>自行安裝 gpedit.msc</p>
<p style="padding-left: 30px;">另外，Windows 11 家用版並沒有 gpedit.msc 工具，這是操作系統的群組原則設置工具，若希望關閉微軟強制設定每 42 天必須重製密碼的內建原則，可以先安裝 gpedit.msc 之後再行修改。</p>
<p style="padding-left: 30px;">在搜尋欄位執行 cmd 之後，選擇以管理者身分啟動命令列視窗後，執行下列批次檔指令:</p>
<p>get_gpedit.bat</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">@echo off
pushd "%~dp0"
dir /b %SystemRoot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;Files.txt
dir /b %SystemRoot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;&gt;Files.txt
for /f %%i in ('findstr /i . Files.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i"
del Files.txt
pause
</pre>
<p style="padding-left: 30px;">完成之後，可以在搜尋處輸入 gpedit.msc，開啟 Local Group Policy Editor，進入 Windows 設定 - 安全設定 - 帳戶原則 - 密碼原則中，若將密碼最長使用期限的 42 天改為 0，則密碼就可由使用者自行決定最長使用期限，不需要每 42 天被強迫更改。</p>
<p>其他建議:</p>
<p style="padding-left: 30px;">安裝 <a href="https://www.7-zip.org/">7zip</a>、安裝 Firefox，之後儘可能使用可攜套件。</p>
<p>二、假如使用 Ubuntu</p>
<p><a href="https://ubuntu.com/#download-ubuntu">Ubuntu</a> 操作系統分為 Server 與 Desktop 版本，一般機械相關的課程所採用的套件大多僅支援 Windows 版，因此 Ubuntu 或其他 Linux 相關操作系統僅是用來建立輔助用的伺服器，或者用於測試所開發的套件是否能夠在 Ubuntu 環境中執行。</p>
<p>在 Windows 11 操作系統中，利用 <a href="https://www.virtualbox.org/wiki/Download_Old_Builds_6_1">Virtualbox</a> 配置一台 Ubuntu 虛擬機，應該是最方便的使用方式，儘管 <a href="https://www.virtualbox.org/wiki/Download_Old_Builds_6_1">Virtualbox</a> 虛擬機僅能模擬大約 75% 的硬體效能，但只要 4GB Ram 與約 5GB 的硬碟空間就可以啟動，因此建議所使用的 Windows 筆電或桌機至少要有 32GB 的記憶體，以及 512 GB 以上的 SSD 硬碟空間.</p>
<p>三、假如使用 Mac</p>
<p><a href="https://en.wikipedia.org/wiki/MacOS">MacOS</a> 採用 BSD 系列操作系統，屬於 Unix，因此就機械相關課程的使用情況，與 Ubuntu 或其他 Linux 操作系統相似，大部分情況必須設法配置 Windows 11 虛擬機，或遠端登入到其他 Windows 11 機器，才能執行一些僅支援 Windows 的套件。  </p>
<p>雲端帳號 two-factor authentication(兩段式認證)</p>
<p>Gmail 帳號:</p>
<p style="padding-left: 30px;">登入 Gmail 帳號後，進入 Google Account，選擇 Manage Google Account</p>
<p style="padding-left: 30px;">點選 Manage Google Account 左方表單中的 Security</p>
<p style="padding-left: 30px;">點選 2-step verification 後，開啟設定</p>
<p style="padding-left: 30px;">畫面將顯示所綁定的手機號碼</p>
<p style="padding-left: 30px;">若要進一步綁訂到 Authenticator，將會出現二維條碼</p>
<p style="padding-left: 30px;">開啟手機中的 Authenticator App(例如: Authy)，新增綁定後用相機拍攝電腦螢幕上的二維條碼</p>
<p style="padding-left: 30px;">將手機 Authenticator 中出現的六個數字輸入電腦設定欄位中，即可完成設定</p>
<h3>llama</h3>
<p>在自己的電腦上執行 <a href="https://en.wikipedia.org/wiki/Llama_(language_model)">llama</a>:</p>
<p style="padding-left: 30px;">若電腦有 GPU 可以加快運算，若只有 CPU 也可以執行，以下採一台安裝 Windows 10 的舊電腦進行示範。</p>
<p>安裝 ollama 工具:</p>
<p style="padding-left: 30px;">連線至 <a href="https://ollama.com">https://ollama.com</a>，下載安裝後，可直接執行 llama3.2 (約 2GB):</p>
<p style="padding-left: 30px;">安裝完成後，ollama 位於: C:\Users\使用者帳號\AppData\Local\Programs\Ollama，可以利用命令列視窗或 Powershell 命令列視窗，更換目錄至 Ollama 之後，以 ollama list 列出已經取下的模型，例如: 系統已經取下 llama3.2，則可利用 ollama run llama3.2 執行。</p>
<p style="padding-left: 30px;">各種開放模擬列表: <a href="https://ollama.com/search">https://ollama.com/search</a>，若要取下 deepseek-r1 模型 (約 5.2GB)：</p>
<p style="padding-left: 60px;">cd <span>C:\Users\使用者帳號\AppData\Local\Programs\Ollama</span></p>
<p style="padding-left: 60px;">ollama pull deepseek-r1</p>
<p style="padding-left: 60px;">ollama run deepseek-r1</p>
<p style="padding-left: 60px;">若要中斷對談，使用 ctrl + c，若要跳出 ollama 的語言模型執行，使用 ctrl + d</p>
<p style="padding-left: 30px;">以下畫面在電腦輔助設計室上一代電腦，配置 Intel i7-6700 CPU @ 3.40GHz，32GB 記憶體，安裝 NVIDIA GeForce GTX 950 顯卡電腦上執行:</p>
<p style="padding-left: 30px;"><img caption="false" height="170" src="/images/ollama_on_win10.png" width="200"/></p>
<p>有關 Llama (資料取自 <a href="https://en.wikipedia.org/wiki/Llama_(language_model)">llama</a>):</p>
<p style="padding-left: 30px;"><b>Llama</b><span> </span>(<b>Large Language Model Meta AI</b>, formerly stylized as<span> </span><b>LLaMA</b>) is a family of<span> </span><a href="https://en.wikipedia.org/wiki/Large_language_model" title="Large language model">large language models</a><span> </span>(LLMs) released by<span> </span><a href="https://en.wikipedia.org/wiki/Meta_AI" title="Meta AI">Meta AI</a><span> </span>starting in February 2023.<span> </span>The latest version is Llama 4, released in April 2025.</p>
<p style="padding-left: 30px;">Llama models come in different sizes, ranging from 1 billion to 2 trillion parameters. Initially only a<span> </span><a href="https://en.wikipedia.org/wiki/Foundation_model" title="Foundation model">foundation model</a>,<span> </span>starting with Llama 2, Meta AI released instruction<span> </span><a href="https://en.wikipedia.org/wiki/Fine-tuning_(deep_learning)" title="Fine-tuning (deep learning)">fine-tuned</a><span> </span>versions alongside foundation models.</p>
<p style="padding-left: 30px;">Model weights for the first version of Llama were only available to researchers on a case-by-case basis, under a non-commercial license.<span> </span>Unauthorized copies of the first model were shared via<span> </span><a href="https://en.wikipedia.org/wiki/BitTorrent" title="BitTorrent">BitTorrent</a>.<span> </span>Subsequent versions of Llama were made accessible outside academia and released under licenses that permitted some commercial use.</p>
<p style="padding-left: 30px;">Alongside the release of Llama 3,<span> </span><a href="https://en.wikipedia.org/wiki/Meta_Platforms" title="Meta Platforms">Meta</a><span> </span>added<span> </span><a href="https://en.wikipedia.org/wiki/Virtual_assistant" title="Virtual assistant">virtual assistant</a><span> </span>features to <a href="https://en.wikipedia.org/wiki/Facebook" title="Facebook">Facebook</a> and <a href="https://en.wikipedia.org/wiki/WhatsApp" title="WhatsApp">WhatsApp</a> in select regions, and a standalone website. Both services use a Llama 3 model.</p>
<h3>nginx</h3>
<p>透過 ollama 與 nginx 的結合，在 Web based 介面中使用 llama:</p>
<p>index.html</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;Ollama Chat&lt;/title&gt;
  &lt;style&gt;
    body { font-family: sans-serif; margin: 2rem; max-width: 700px; }
    textarea { width: 100%; height: 100px; }
    pre { background: #eee; padding: 1em; white-space: pre-wrap; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;🧠 Chat with LLaMA (via Ollama)&lt;/h1&gt;
  &lt;textarea id="prompt" placeholder="Say something..."&gt;&lt;/textarea&gt;&lt;br/&gt;
  &lt;button onclick="send()"&gt;Send&lt;/button&gt;
  &lt;pre id="output"&gt;&lt;/pre&gt;

  &lt;script&gt;
    async function send() {
      const prompt = document.getElementById("prompt").value;
      document.getElementById("output").textContent = "Thinking...";
      const res = await fetch("/api/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "llama3",
          prompt,
          stream: false
        })
      });
      const result = await res.json();
      document.getElementById("output").textContent = result.response;
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>nginx.conf 中對應的 server 設定:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">server {
    listen 80;
    server_name your.domain.com;

    location / {
        root /var/www/html;
        index index.html;
    }

    location /api/ {
        proxy_pass http://localhost:11434/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}</pre>
<p>執行 ollama serve 或使用 ollama run 時，ollama 套件會在 http://localhost:11434 開啟一個 RESTful API 伺服器，讓你可以透過程式或前端介面與模型互動。</p>
<p>因此執行 ollama run llama3.1:latest 之後，再伺服 nginx 的 index.html 後，就可以從 WWW 伺服器連接頁面上，與 llama 語言模型系統對話。</p>
<p>若 ollama 所執行的模型支援 vision 功能，則可以進一步延伸 index.html，使用者可以上傳圖片與 AI 模型對話</p>
<p>index_vision.html</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;Ollama Chat + Image/File Upload&lt;/title&gt;
  &lt;style&gt;
    body { font-family: sans-serif; max-width: 800px; margin: 2rem auto; }
    textarea { width: 100%; height: 80px; }
    .chatbox { white-space: pre-wrap; background: #f4f4f4; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; }
    .file-label { margin-top: 0.5rem; display: block; font-weight: bold; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h2&gt;Chat with LLaMA + Upload Image/Text&lt;/h2&gt;
  
  &lt;div class="chatbox" id="chatlog"&gt;&lt;/div&gt;

  &lt;textarea id="prompt" placeholder="Say something..."&gt;&lt;/textarea&gt;&lt;br&gt;
  
  &lt;label class="file-label"&gt;Upload image (.png/.jpg) or text (.txt/.md):&lt;/label&gt;
  &lt;input type="file" id="fileInput" accept=".png,.jpg,.jpeg,.txt,.md"&gt;&lt;br&gt;&lt;br&gt;
  
  &lt;button onclick="send()"&gt;Send&lt;/button&gt;

  &lt;script&gt;
    const chatlog = document.getElementById("chatlog");

    async function send() {
      const promptInput = document.getElementById("prompt").value.trim();
      const fileInput = document.getElementById("fileInput");
      if (!promptInput &amp;&amp; fileInput.files.length === 0) return;

      let userMessage = promptInput || "[No prompt]";
      let fullPrompt = promptInput;

      // 檔案處理
      if (fileInput.files.length &gt; 0) {
        const file = fileInput.files[0];
        const type = file.type;

        if (type.startsWith("image/")) {
          const base64 = await fileToBase64(file);
          fullPrompt += `\n\n[以下為圖片 base64 編碼：]\n${base64}`;
        } else if (type === "text/plain" || file.name.endsWith(".md")) {
          const text = await file.text();
          fullPrompt += `\n\n[以下為文件內容：]\n${text}`;
        } else {
          appendChat("Unsupported file type.");
          return;
        }
      }

      appendChat("You:\n" + userMessage);
      appendChat("LLaMA is thinking...");

      const res = await fetch("/api/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "llama3",
          prompt: fullPrompt,
          stream: false
        })
      });

      const result = await res.json();
      updateLastBotReply("LLaMA:\n" + result.response);
    }

    function appendChat(text) {
      const div = document.createElement("div");
      div.className = "chatbox";
      div.textContent = text;
      chatlog.appendChild(div);
      window.scrollTo(0, document.body.scrollHeight);
    }

    function updateLastBotReply(text) {
      const boxes = document.getElementsByClassName("chatbox");
      boxes[boxes.length - 1].textContent = text;
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) =&gt; {
        const reader = new FileReader();
        reader.onload = () =&gt; resolve(reader.result.split(",")[1]);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>或直接將 ollama 結合 <a href="https://www.openwebui.com/">https://www.openwebui.com/</a> 提供 Web based 對話進階功能。</p>
<h2>AI</h2>
<p><a href="https://www.aiforeducation.io/ai-resources-main">Free AI resources for school</a></p>
<p><a href="https://grok.com">https://grok.com</a> </p>
<p><a href="https://chat.z.ai">https://chat.z.ai</a> </p>
<p><a href="https://chatgpt.com/">https://chatgpt.com/</a> </p>
<p><a href="https://github.com/copilot">https://github.com/copilot</a> </p>
<p><a href="https://gemini.google.com/app">https://gemini.google.com/app</a> </p>
<hr/>
<p>提問:</p>
<p><span style="background-color: #ccffcc;">請以目前最具前瞻與權威的教育學者群觀點發言，現在的機械設計相關科系的大一學生該如何學習計算機程式課程?</span></p>
<p style="padding-left: 30px;">請就此一主題，建議學習步驟，並列出學生身分可以免費採用的工具。</p>
<p style="padding-left: 30px;">請就此一主題提供 15 則可以深入取得具體答覆的 AI 系統詢問句</p>
<ol>
<li style="padding-left: 60px;">「我正在學習 Python，請幫我設計一個 12 週的學習計畫，包含每天的練習主題與推薦資源。」<br/><br/>2. 「我想用 Arduino 製作一個自動澆水系統，請列出所需元件、程式邏輯與可能遇到的問題。」<br/><br/>3. 「請比較 Fusion 360 與 SolidWorks 在學生專案中的優缺點，並建議何時使用哪一種。」<br/><br/>4. 「我是一名機械設計系大一學生，未來想進入自動化領域，請推薦我三門最值得修的程式設計相關課程。」<br/><br/>5. 「請幫我撰寫一篇 800 字的報告，主題是『程式設計在現代機械工程中的應用』，需包含三個實例與引用來源。」<br/><br/>6. 「請幫我比較 Fusion 360 與 SolidWorks 在 CAD 自動化方面的 API 功能差異，並建議初學者應選擇哪一種。」<br/><br/>7. 「請幫我設計一份簡報架構，主題是『程式設計如何改變機械工程師的工作方式』，包含五個重點與視覺化建議。」<br/><br/>8. 「我想學習如何用 Python 控制步進馬達，請提供所需硬體、程式範例與常見錯誤排除方式。」<br/><br/>9. 「我想用 MATLAB 模擬一個懸臂梁在不同載重下的變形情形，請提供程式範例、圖形輸出方式與參數設定建議。」<br/><br/>10. 「請幫我設計一個 GitHub 專案架構，用來整理我在機械設計領域的程式作品集，包括資料夾命名、README 撰寫與版本控制建議。」<br/><br/>11. 「我正在準備期末報告，主題是『嵌入式系統在智慧製造中的應用』，請列出三個具體案例並提供引用來源。」<br/><br/>12. 「請幫我撰寫一段 Arduino 程式碼，讓紅外線感測器偵測到人時啟動伺服馬達，並附上接線圖與元件清單。」<br/><br/>13. 「我想用 Python 建立一個簡單的 GUI 工具，讓使用者輸入齒輪參數後自動產生 Fusion 360 腳本，請提供程式架構與推薦套件。」<br/><br/>14. 「請幫我設計一個模擬機械臂運動的 Python 程式，包含關節角度輸入、運動軌跡計算與視覺化繪圖。」<br/><br/>15. 「我想了解 ROS（Robot Operating System）在機械工程中的應用，請列出三個實例並說明如何開始學習 ROS。」</li>
</ol>
<h3>Learning</h3>
<p><a href="https://link.springer.com/book/10.1007/978-981-96-0029-8">Essentials of Generative AI</a></p>
<p><a href="https://link.springer.com/book/10.1007/978-3-031-84724-0">A Beginner’s Guide to Generative AI</a></p>
<p><a href="https://link.springer.com/book/10.1007/978-3-031-60179-8">Generative AI in Higher Education</a></p>
<p><a href="https://www.ed.gov/sites/ed/files/documents/ai-report/ai-report.pdf">AI 世代教與學的未來</a></p>
<p><a href="https://link.springer.com/book/10.1007/978-981-96-2355-6">Multimodal Generative AI</a></p>
<p><a href="https://link.springer.com/book/10.1007/979-8-8688-0844-9">Generative AI in Education</a></p>
<p><a href="https://link.springer.com/book/10.1007/979-8-8688-1134-0">Building Generative AI Agents</a></p>
<p><a href="https://link.springer.com/book/10.1007/979-8-8688-0885-2">Generative AI for Web Development</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/JbULLz84xoY?si=vTIypEslfQHpnBSs" title="YouTube video player" width="560"></iframe></p>
<h3>QandA</h3>
<p>什麼是 Git？</p>
<p style="padding-left: 30px;">Git 是一套 版本控制工具，可以用來追蹤檔案的修改歷史，讓你可以回到過去的版本、比較變更、多人協同創作。</p>
<p style="padding-left: 30px;">適用：純文字檔案（程式碼、筆記、Markdown、論文等）</p>
<p style="padding-left: 30px;">也可以用在 binary data（圖片、影片等），但效率差、不建議</p>
<p style="padding-left: 30px;">因為無法有效比較或壓縮 binary 的差異</p>
<p>什麼是 GitHub？</p>
<p style="padding-left: 30px;">GitHub 是一個線上平台，用來儲存 Git 專案、分享程式碼、團隊協同創作。</p>
<p style="padding-left: 30px;">適用：開發專案、筆記、個人網站、報告等</p>
<p style="padding-left: 30px;">支援 Git 的功能（如歷史紀錄、分支、協作）</p>
<p style="padding-left: 30px;">支援上傳 binary，但有大小限制（單檔 100MB、整體推薦 &lt;1GB）</p>
<p style="padding-left: 30px;">大型檔案可搭配 Git LFS（進階用法）</p>
<p>什麼是 Gist？</p>
<p style="padding-left: 30px;">Gist 是 GitHub 的一個功能，用來快速分享小段程式碼或純文字內容（像筆記、代碼片段）。</p>
<p style="padding-left: 30px;">適用：分享小段 code、設定檔、筆記、Markdown</p>
<p style="padding-left: 30px;">不支援上傳 binary 檔案</p>
<p style="padding-left: 30px;">本質上仍是用 Git 管理的</p>
<p>如何透過 git 使用 Gist?</p>
<p style="padding-left: 30px;">僅讀取 gist 檔案資料，並無權限維護:</p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">git clone https://gist.github.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de ex</span></p>
<p style="padding-left: 30px;">以上指令表示要將位於 mdecycu 帳號下 Gist ID 為 71ff1c69dd233e6a5a83dd60997950de 的倉儲內容取下，且放入 ex 目錄中。</p>
<p style="padding-left: 30px;">假如具備維護 gist 檔案資料的權限，則可以利用 Putty 中的 puttygen.exe 建立 OpenSSH 格式的 public key，並將其放入 Github 帳號下 Settings - SSH and GPG keys 中的 new SSH keys 欄位中，然後將格式為 Putty private key (ppk) 的私鑰存放在個人電腦或隨身碟中。然後利用 putty.exe 建立一個能以 Connection - Data - Auto-login Username 為 git，且 Host Name 為 gist.github.com 的 Session。並將此 Session 的 Connection - SSH - Auth - Credential 私鑰欄位填上 private key .ppk 的位置，即可完成此專用於連線到 Gist 的 Session 設定。假設此 Gist Session 名稱設為 "gist"。</p>
<p style="padding-left: 30px;">則可用於後續維護 Gist 檔案內容的 git clone 指令為 (以下的 gist 代表 Putty 中所設定專用於 Gist 的 Session 名稱):</p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">git clone git@gist:71ff1c69dd233e6a5a83dd60997950de.git ex2</span></p>
<p style="padding-left: 30px;">一旦 ex2 目錄中各檔案維護告一段落後，可以進入 ex2 目錄，利用 git add .，git commit -m "提交訊息" 與 git push 將修改後的近端內容新增提交推送至 Gist 伺服器。</p>
<p style="padding-left: 30px;">若希望直接在近端取得目前最新版本的檔案版本號，可以在 ex2 目錄中利用 git log -1 查詢最後一次提交的版本號，然後以下列 URL 取得 Gist 中 brython_robot.py 檔案的最新內容:</p>
<p style="padding-left: 30px;">https://<span style="background-color: #ccffcc;">gist.githubusercontent.com</span>/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/27541a79c916e42c1f32509aa3a1c6e086923d47/brython_robot.py</p>
<p style="padding-left: 30px;">其中 71ff1c69dd233e6a5a83dd60997950de 為 Gist ID，而 27541a79c916e42c1f32509aa3a1c6e086923d47 就是透過 git log -1 取得的最新版本號。</p>
<p style="padding-left: 30px;">另外，若已經利用 Github 帳號下的 Settings - Developer Settings - Tokens (classic) 建立可以 Create gists 的 token，可以利用 PyGithub 模組，利用 <a href="/downloads/generate_gist.py">generate_gist.py</a> 建立 Gist 倉儲，待取得所建立 Gist 的 ID 之後，就可以將此 Gist clone 至近端維護後，再提交推送回對應帳號下的 Gist 倉儲。</p>
<h3>Teams</h3>
<p><a href="/downloads/cmsimde_ai_1.txt">cmsimde_ai_1.txt</a></p>
<p><img alt="" height="290" src="/images/copilot_answer_cmsimde_teams.png" width="300"/></p>
<p>本課程利用 Github Classroom 由各組組長建立 Team (團隊) 後，再由組員逐一加入團隊，每組最多 6 名組員。</p>
<p>由於各組的網站是由 6 位組員協同編輯，因此其過程的專案描述如下:</p>
<p><span style="background-color: #ccffcc;">目前有一個專案，透過解析 config/content.htm 檔案中 HTML 的 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt; 標籤來進行內容分頁，並以這些標題作為靜態網站中各頁面的標題。系統根據 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt; 的層級順序，動態建立多層次的網站導覽選單 (menu)。</span><br/><br/><span style="background-color: #ccffcc;">content.htm 的內容編輯採用 Python Flask 搭配 JavaScript 編輯器，讓使用者能在瀏覽器中即時編輯各層級頁面的內容。編輯完成後，透過 Python 程式將內容分頁並產生含多層次選單的靜態頁面，並存放於 content 目錄中。</span><br/><br/><span style="background-color: #ccffcc;">針對此一網站，若由六名組員同步協同維護，組員可選擇在本地端啟動動態編輯環境完成內容修改及靜態頁面生成，或直接利用 GitHub Codespaces 進行雲端開發。請詳述並說明在此協同編輯流程中會使用的 Git 指令與使用情境，同時指導各組員應如何有效同步作業以確保版本一致與作業流暢。</span></p>
<p><span style="background-color: #ccffcc;"></span>專案概述與協同維護流程建議</p>
<p>一、專案概述<br/><br/>本專案透過解析 config/content.htm 檔案中的 HTML 標籤 &lt;h1&gt;、&lt;h2&gt; 及 &lt;h3&gt;，實現內容分頁功能。系統將這些標題作為靜態網站中各頁面的標題，並依據標題的層級順序，動態生成多層次的網站導覽選單（Menu），以提升使用者瀏覽體驗。<br/><br/>內容編輯採用 Python Flask 框架結合 JavaScript 編輯器，讓使用者能直接在瀏覽器中編輯各層級頁面內容。完成內容編輯後，系統透過 Python 程式將分頁資料轉換為帶有多層次選單的靜態網頁，並將生成的靜態頁面存放於 content 目錄中。</p>
<p>二、協同維護環境</p>
<p>為提升協作效率，六名組員可選擇：<br/><br/>在本地端啟動動態編輯環境，進行內容修改及靜態頁面生成。<br/><br/>直接利用 GitHub Codespaces 進行遠端雲端開發與協作。</p>
<p>三、協同編輯與版本同步建議</p>
<p>針對六人團隊的同步維護，建議採用以下工作流程：</p>
<p>版本控管</p>
<p style="padding-left: 30px;">使用 Git 進行版本管理，並採用分支（Branch）策略，每位組員於獨立分支上進行內容編輯，避免直接衝突。</p>
<p>本地或雲端編輯</p>
<p style="padding-left: 30px;">組員可在本地端或 Codespaces 環境中，透過 Flask + JavaScript 編輯器進行內容更新，並執行 Python 程式生成靜態頁面以供預覽與測試。</p>
<p>提交與合併流程</p>
<p style="padding-left: 30px;">編輯完成後，組員將修改提交至個人分支並推送至遠端倉庫，透過 Pull Request (PR) 進行代碼審核與合併，確保內容品質及版本一致。</p>
<p>衝突管理與溝通協調</p>
<p style="padding-left: 30px;">由於多組員共同編輯相同檔案，需定期拉取主分支最新版本，及時解決合併衝突。團隊成員間應保持密切溝通，避免重複編輯同一內容區塊。</p>
<p>自動化測試與部署</p>
<p style="padding-left: 30px;">可結合 CI/CD 工具，於 PR 流程中自動執行靜態網站生成及測試，確保產出結果符合預期，並自動部署至測試或正式環境。</p>
<p>此工作流程能有效保障多名組員在分散開發環境下，協同完成內容維護與靜態頁面產出，提升團隊合作效率與網站品質。</p>
<h2>Homework</h2>
<p>HW1:</p>
<p style="padding-left: 30px;">請將程式碼存放在個人作業倉儲中的 python 目錄後，利用程式連結完成下列任務:</p>
<p style="padding-left: 60px;"><a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround1.json">around1</a>, <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround2.json">around2</a>, <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround3.json">around3</a>, <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround4.json">around4</a></p>
<p>HW2:</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py">Brython_robot</a> 程式，讓機器人可以採水平巡邏方式，走過每一個區域。</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py">Brython_robot</a> 程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。</p>
<p>HW3:</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a> 程式，讓機器人可以與<a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Fharvest1.json&amp;editor=python%2Fharvest1_east_west.py">機器人收割程式</a>的水平採收方式相同。</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a> 程式，讓機器人可以與<a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Fharvest1.json&amp;editor=python%2Fharvest1.py">機器人收割程式</a>的上下垂直採收方式相同。</p>
<p>HW4:</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a> 程式，讓機器人可以與<a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Fharvest3.json&amp;editor=python%2Fharvest1_class_ex3.py">機器人收割程式</a>的採收與播種方式相同。</p>
<p style="padding-left: 30px;">請修改 Pyodide <a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/d1659628afe5d36a026ef305dc639f6be4c9f608/pyodide_robot_ex3.py">機器人自由行</a>程式，讓機器人可以採水平巡邏方式，走過每一個區域。</p>
<p style="padding-left: 30px;">請修改 Pyodide <a href="https://mde.tw/cp2025/content/Pyodide2.html?src=https%3A%2F%2Fgist.githubusercontent.com%2Fmdecycu%2Fec4bb35dd0769e7a83d2a9fa57878a67%2Fraw%2Fff833d14181c7e270d37432aa8589f5ecf00e383%2Fpyodide_walk_around2.py">機器人自由行2</a>程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。</p>
<p></p>
<p></p>
<p style="padding-left: 30px;"></p>
<h1>Topics</h1>
<p>w1:</p>
<p><a href="https://mde.tw/w1">https://mde.tw/w1</a> for 1a </p>
<p style="padding-left: 30px;">利用 Codespaces 維護 Github Pages 網站內容</p>
<p style="padding-left: 30px;">利用 portable_2026 可攜系統維護 Github Pages 網站內容</p>
<p style="padding-left: 60px;">透過 Token 取得維護權限</p>
<p style="padding-left: 60px;">y:\home_ipv6\.gitconfig 中設定</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">[http "https://github.com"]
    sslVerify = false</pre>
<p style="padding-left: 60px;">表示當採 https 連線到 github.com 時，停用 SSL 憑證驗證，雖然方便，但若透過公眾網路上網，將會暴露在中間人攻擊(<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">MITM</a>)的風險。</p>
<p style="padding-left: 60px;">或者</p>
<p style="padding-left: 60px;">git config --global http.sslCAInfo "y:\PortableGit\usr\ssl\certs\ca-bundle.crt"</p>
<p style="padding-left: 60px;">啟用 SSL 憑證驗證。</p>
<p><a href="https://41423299.github.io/w1">https://41423299.github.io/w1</a> for 1b</p>
<p style="padding-left: 30px;">利用 Codespaces 維護 Github Pages 網站內容</p>
<p style="padding-left: 30px;">Take Home 問題: 近端維護 Github Pages 網站時，有哪兩種管理權限驗證方式?</p>
<p>w2:</p>
<p style="padding-left: 30px;">開始透過 <a href="https://mde.tw/cp2025/content/Robot_ex.html">https://mde.tw/cp2025/content/Robot_ex.html</a> 學習 Python 程式語法。</p>
<p style="padding-left: 30px;">當了解如何<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex1.py">控制機器人直行</a>之後，若又對機器人加了一個左轉的功能 - turn_left()，機器人是否已經可以在平面場區中自由行動。</p>
<p style="padding-left: 30px;">假如又知道機器人在創始階段，是透過 World(10, 10) 方法，建立一個 10 x 10 的平面場區，那麼場景範圍應該可以自由控制大小。</p>
<p style="padding-left: 30px;">接下來，請結合上述資訊，修改<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex1.py">控制機器人直行</a>程式，讓機器人的足跡踏遍 10 x 10 場區的每一格。</p>
<p style="padding-left: 30px;">這樣，也能完成踏遍 20 x 20 場區的每一格嗎?</p>
<p style="padding-left: 30px;">Python 基本語法: <a href="https://link.springer.com/chapter/10.1007/978-3-031-90522-3_1">Python essential</a> (只能在校網擷取)</p>
<p style="padding-left: 30px;">應用函式定義與 for 重複迴圈，可以導引機器人在 20x20 的場景中<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/d6d229925f852c97fc71abe1fa0620c4/raw/bb1b4c63ef692fd8c61f339dbd59c413e7405573/w2_1.py">走過</a>每一格。</p>
<p style="padding-left: 30px;">利用上列程式，再設定繞行所有網格的程式為 walk_all_grid() 函式，可以適用不同大小的網格場景<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/d6d229925f852c97fc71abe1fa0620c4/raw/e221415e8e698159a9cc947ab09f3c53b36bb33e/horizontal_walk_all_grid.py">行走</a>。</p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">程式練習</span>: 上面的機器人行走範例，採水平路線行走，請各分組學員設法修改為採垂直路線繞行所有網格的版本。</p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/b2c368eff8c00f9987b0b56d1d290988402603ad/1b_w2_1.py">1b w2_1.py</a></p>
<p style="padding-left: 30px;"><span style="background-color: #ffcc99;">問題</span>: 不知道您有沒有注意到，上面的網格尺寸都是整數，因此<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/d6d229925f852c97fc71abe1fa0620c4/raw/bb1b4c63ef692fd8c61f339dbd59c413e7405573/w2_1.py">走過</a>每一格，以及<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/d6d229925f852c97fc71abe1fa0620c4/raw/e221415e8e698159a9cc947ab09f3c53b36bb33e/horizontal_walk_all_grid.py">行走</a>的程式都不會造成問題，</p>
<p style="padding-left: 30px;">但若網格的尺寸不是整數而是奇數 (例如: 利用先前設計<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/d6d229925f852c97fc71abe1fa0620c4/raw/85f4d857f267ebca6a6f401c889a3a6ad8629096/walk_11x11.py">行走 11x11 網格</a>)，應該如何修改? 目標是無論 size 是整數或是奇數，無論是水平或垂直繞行，機器人都要能順利完成繞行經過每一格的任務。</p>
<p>w3: <a href="https://mde.tw/cp_demo/content/Python.html">Python 程式語法學習</a></p>
<p style="padding-left: 30px;">利用 <a href="https://github.com/scrum-1/respysive-slide">https://github.com/scrum-1/respysive-slide</a> 製作簡報，設法可以多人採分散式版次管理流程製作協同專案的線上簡報內容。</p>
<p style="padding-left: 30px;">讓簡報製作就像寫 Python 程式一樣，可以分散式協同，方便非同步內容管理與合併，可以直接在線上進行簡報。</p>
<p>w4: 機電系統設計，其實是一連串的數學解題與程式設計。</p>
<p style="padding-left: 30px;">電腦輔助機械設計套件（Computer-Aided Mechanical Design Package），本質上是一種結合<strong data-end="1401" data-start="1378">數學建模、工程物理、計算模擬與資訊技術</strong>的工具，主要目的是幫助工程師在數位空間中完成設計、分析與製造準備工作。</p>
<p style="padding-left: 30px;">電腦輔助機械設計套件的本質是透過電腦建模與模擬技術，把機械工程師的設計概念數位化，並透過虛擬工具進行驗證與最佳化。</p>
<p style="padding-left: 30px;">這些結合數學幾何模型與計算機程式的工具，讓工程師能夠 1) 在虛擬空間中繪製零件與組件 2) 模擬材料與力學行為 3) 取得最佳化設計參數 4) 快速修改與試驗不同方案 5) 避免昂貴的實體原型開發與測試。</p>
<p style="padding-left: 30px;">設計案例: <a href="https://mde.tw/cad_demo/content/Plotter.html">Plotter</a>，<a href="https://mde.tw/cad_demo/content/Openduck.html">Openduck</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/d1f7266329c2e18800c236f8c639b1de0317a591/cp_w4_robot_animation.py">機器人行走模擬程式</a>，存為程式模組之後，利用向量運算<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/f354f7b128bcbb8c41aa059d2749d92d89ebb8bb/w4_vector_control_robot.py">控制機器人行進方向</a></p>
<p style="padding-left: 30px;">若直接在瀏覽器中執行<a href="https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/26e0aa0ac5ee0b5cfdceb559a4bd2bd5e4c382b8/w4_A_star_searching.py">較密集運算</a>時，瀏覽器回覆執行速度過慢時，該如何處理?</p>
<p>w5-w12: 深入理解<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/d1f7266329c2e18800c236f8c639b1de0317a591/cp_w4_robot_animation.py">機器人行走模擬程式</a>中的所有 Python 與 Brython 程式用法。</p>
<p style="padding-left: 30px;">Prompt:</p>
<p style="padding-left: 60px;">請針對 from browser import document, html, timer, bind 中導入的物件各舉 10 個案例詳細說明。</p>
<p style="padding-left: 60px;">請詳細說明以下程式各行的用法: (隨後將程式碼附上)</p>
<p style="padding-left: 30px;">說明如何將 Brython 程式直接放入網頁中執行。</p>
<p style="padding-left: 30px;">w7: <a href="/downloads/websocket_robot.7z">websocket_robot.7z</a> (納入由遠端鍵盤控制 robot)</p>
<p style="padding-left: 30px;">localhost websocket 應用: <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/159e3ccc2fe4c2027ed3a676273573bb/raw/b7bd9fb81c8faf3eb229ef4cda46200b7a5aab6e/brython_websocket1.py">brython 端</a>，<a href="https://gist.githubusercontent.com/mdecycu/159e3ccc2fe4c2027ed3a676273573bb/raw/b7bd9fb81c8faf3eb229ef4cda46200b7a5aab6e/websocket_server1.py">server 端</a></p>
<p style="padding-left: 30px;">IPv4 與 IPv6 websocket 應用: <a href="/downloads/brython_websocket_app.7z">brython_websocket_app.7z</a></p>
<p style="padding-left: 60px;">如何將 websocket 應用到 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/d1f7266329c2e18800c236f8c639b1de0317a591/cp_w4_robot_animation.py">機器人行走模擬程式</a>?</p>
<p style="padding-left: 30px;">w7 1b 題目:</p>
<p style="padding-left: 60px;">請導引 robot 走到 10x10 格點，以 (5, 5) 為中心畫一個 2x2 的正方形線條</p>
<p style="padding-left: 90px;">可以直接將 robot 的起始位置訂為畫線起點，再逐一畫出 4 條線</p>
<p style="padding-left: 90px;">若從 (1,1) 開始<span style="background-color: #ffff00;">走到</span>畫線起點，也可以逐一畫出所需的 4 條線 (<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/488e94c6a6f0c3f63dbae5e1d0e61a7ab8a812d7/w7_1b_ex1.py">範例</a>)</p>
<p style="padding-left: 90px;">若能新增一個 move2() 是不會留下紅色軌跡的函式，該如何編寫?</p>
<p style="padding-left: 90px;">若已經知道可以透過 git checkout c0d70cd 將倉儲內容切回第四週的版本，請列出新舊<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/d1f7266329c2e18800c236f8c639b1de0317a591/cp_w4_robot_animation.py">機器人行走模擬程式</a>的修改細節。</p>
<p style="padding-left: 90px;">新增 move3(x1, y1, x2, y2) 可以從 (x1, y1) 走到 (x2, y2), 留下斜線路徑的 <a href="https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/d529e57369b9b6fd6668fd3c42b6dcea5b4a652c/cp_w4_robot_animation.py">robot_lib.py</a>。</p>
<p style="padding-left: 30px;">w8:</p>
<p style="padding-left: 60px;">請各分組採協同製作的流程完成下列任務:</p>
<p style="padding-left: 90px;">設法利用<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/d1f7266329c2e18800c236f8c639b1de0317a591/cp_w4_robot_animation.py">機器人行走模擬程式</a>，列出與 Python <a href="/downloads/python_keywords.txt">所有關鍵字</a>有關的程式應用範例。</p>
<p style="padding-left: 90px;">設法利用機器人的行走練習與 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Reference/Elements/canvas">Html5 Canvas</a> 有關的各種繪圖程式練習。</p>
<p style="padding-left: 60px;">Brython 程式位於瀏覽器前端，若要將表單上的資料儲存至後端，就必須與 Python 程式.</p>
<p style="padding-left: 60px;">兩端如何溝通: 使用傳統的 ajax 或 websocket? Python 數值運算或檔案轉換後的<span style="background-color: #ffff00;">資料如何存檔</span>?</p>
<p style="padding-left: 90px;">如何利用 Python 讀進 <a href="/downloads/robot_lib.txt">robot_lib.txt</a> 檔案，並用 print 將內容列出?</p>
<p style="padding-left: 60px;">Python 資料結構: list、tuple、dictionary、set 如何應用?</p>
<p style="padding-left: 60px;">Python 與資料庫 (Database): SQLite、PostgreSQL、MySQL、MS SQL</p>
<p>w11: 如何將先前已經運作的協同倉儲提交紀錄，推送到 Github Classroom 中的協同倉儲</p>
<p style="padding-left: 30px;">在 Codespaces 中採用 token 權限進行:</p>
<p style="padding-left: 60px;">利用 <span style="background-color: #ccffcc;">ctrl + p</span> 可以顯示或編輯 .git/config</p>
<p style="padding-left: 60px;">利用 git remote add 代號 github_classroom_repo_url.git 可以將代號與 url 新增至 .git/config 中</p>
<p style="padding-left: 60px;">建立 token，並將 token 放入 <span>github_classroom_repo_url .git 中</span></p>
<p style="padding-left: 60px;"><span>git push 代號 main 可以將先前倉儲的 main 分支推送至 Github Classroom 中的協同倉儲</span></p>
<p style="padding-left: 30px;">在近端可攜程式環境中進行 (已經有協同倉儲):</p>
<p style="padding-left: 60px;">cd 到先前運作的協同倉儲目錄</p>
<p style="padding-left: 60px;"><span>利用 git remote add 代號 github_classroom_repo_url.git 可以將代號與 url 新增至 .git/config 中</span></p>
<p style="padding-left: 60px;">建立 token，並將 token 放入 <span>github_classroom_repo_url.git 中</span></p>
<p style="padding-left: 60px;"><span>git push 代號 main 可以將先前倉儲的 main 分支推送至 Github Classroom 中的協同倉儲</span></p>
<p style="padding-left: 30px;"><span>在近端可攜程式環境中進行 (尚未有協同倉儲):</span></p>
<p style="padding-left: 60px;">登入 Github 後，連結到 <a href="https://github.com/mdecycu/cmsimde_site">https://github.com/mdecycu/cmsimde_site</a> 先建立 cmsimde 架構的倉儲</p>
<p style="padding-left: 60px;">接下來在 Codespaces 環境將上一個建立的倉儲推送到 <span>github_classroom_repo_url .git 中</span></p>
<p style="padding-left: 60px;">或利用近端環境<span>將上一個建立的倉儲推送到 </span><span>github_classroom_repo_url .git 中</span></p>
<p style="padding-left: 30px;">接下來進入 <a href="https://s5.eng.nfu.edu.tw:9499">https://s5.eng.nfu.edu.tw:9499</a> 註冊新帳號，登入後可以將自己寫的 brython 程式存檔 (機器人程式庫: <a href="/downloads/robot_lib.py">robot_lib.py</a>)</p>
<hr/>
<p style="padding-left: 30px;">接著將<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/d1f7266329c2e18800c236f8c639b1de0317a591/cp_w4_robot_animation.py">機器人行走模擬程式</a>存為程式模組之後，利用向量運算<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/f354f7b128bcbb8c41aa059d2749d92d89ebb8bb/w4_vector_control_robot.py">控制機器人行進方向</a>，或進行其他應用。</p>
<p style="padding-left: 30px;">後續應用 Prompt:</p>
<p style="padding-left: 60px;">利用以下的 Brython 機器人在格點中行走的模擬程式作為模組, 存為 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/5dd2d47ddab3a52bf6477f75e3f548216cf0de60/cp_w4_robot_animation.py">robot_lib.py</a> 之後, 請利用 import robot_lib 作為開端，舉八個可以用來學習演算法的典型範例，請注意這是 Brython, 因此可能無法進行密集的運算，因此另外再舉五個可以結合此 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/b81cebd4eba83488040fb444e065692ef2da76f2/cp_w4_robot_animation.py">robot_lib.py</a> 作為模組 import，但是卻利用與遠端 Flask 程式結合運算的案例，讓 Brython 負責前端的動態模擬，較為複雜的運算則透過 ajax 或其他方法，將運算送到 Server 運算後，有 Brython 前端程式負責模擬: (接著將 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/b81cebd4eba83488040fb444e065692ef2da76f2/cp_w4_robot_animation.py">robot_lib.py</a> 程式碼貼上)</p>
<p style="padding-left: 30px;">十個學習演算法的典型範例:</p>
<p style="padding-left: 30px;">一、<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/aa66c4a85dae81189c394ea75d023ef8/raw/989580879f409f41551759e82345c4feeea3e363/random_walk.py">隨機漫遊</a> (Random Walk)</p>
<p style="padding-left: 60px;">讓機器人進行隨機行走，學習如何實現隨機選擇方向，並處理邊界條件。</p>
<p style="padding-left: 30px;">二、<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/aa66c4a85dae81189c394ea75d023ef8/raw/419b5683116435127e814098329c67ab5d04d0ca/maze_solution.py">迷宮尋路</a> (Maze Solving)</p>
<p style="padding-left: 60px;">讓機器人在一個包含牆壁的地圖中尋找最短路徑，可以使用 A* 算法或深度優先搜尋 (DFS) 算法。</p>
<p style="padding-left: 30px;">三、<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/aa66c4a85dae81189c394ea75d023ef8/raw/d922db84457110c7e1c0d405199349ff09431499/shorted_path.py">最短路徑搜尋</a> (Shortest Path Search)</p>
<p style="padding-left: 60px;">給定一個有障礙物的地圖，讓機器人找到從起點到終點的最短路徑。可以學習使用 Dijkstra 演算法或 A* 演算法。</p>
<p style="padding-left: 30px;">四、<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/aa66c4a85dae81189c394ea75d023ef8/raw/c51b4c7a90e062a597dc587a28a9e976d0e52715/patrolling.py">巡邏模式</a> (Patrolling)</p>
<p style="padding-left: 60px;">讓機器人自動巡邏一個指定區域，並根據一定規則改變方向，學習簡單的自動化模式。</p>
<p style="padding-left: 30px;">五、<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/aa66c4a85dae81189c394ea75d023ef8/raw/510c60404a01829e9842b3a705d5d4a94fb17011/pick_and_place.py">物品拾取與放置</a> (Pickup and Place)</p>
<p style="padding-left: 60px;">讓機器人在地圖中尋找物品並將其放置到指定位置，學習如何控制機器人的移動與狀態轉換。</p>
<p style="padding-left: 30px;">六、<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/aa66c4a85dae81189c394ea75d023ef8/raw/3e85051af7791d38f3f2991397f658711166e9b6/obstacle_avoidance.py">避障</a> (Obstacle Avoidance)</p>
<p style="padding-left: 60px;">讓機器人避開障礙物，學習如何根據傳感器數據進行即時決策，避免碰撞。</p>
<p style="padding-left: 30px;">七、<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/aa66c4a85dae81189c394ea75d023ef8/raw/35212484a494d48eca0a95cd8a2562c9f6373c5f/object_circling.py">圍繞物體行走</a> (Object Circling)</p>
<p style="padding-left: 60px;">讓機器人圍繞地圖中的某個物體行走，學習如何調整其行為以保持固定的圓形路徑。</p>
<p style="padding-left: 30px;">八、<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/aa66c4a85dae81189c394ea75d023ef8/raw/281d59aae380be6c627413166596ce98cd31dee9/boundary_exploration.py">邊界探索</a> (Boundary Exploration)</p>
<p style="padding-left: 60px;">讓機器人沿著邊界走，並學習如何使用循環條件處理邊界情況。(<a href="https://gist.githubusercontent.com/mdecycu/aa66c4a85dae81189c394ea75d023ef8/raw/be404af67b7b10cc48e7bb734ac70a356f3674cf/boundary_exploration_and_stop.py">探索一圈後停止</a>)</p>
<p style="padding-left: 30px;">五個結合 Flask 程式的運算案例:</p>
<p style="padding-left: 30px;">Brython 的運算能力有限，複雜的計算可交給後端 Flask 處理，前端用於動態顯示模擬。以下是五個結合 Flask 與 Brython 的範例：</p>
<p style="padding-left: 30px;">一、迷宮生成與尋路</p>
<p style="padding-left: 60px;">描述: 在 Flask 後端生成一個隨機迷宮，並使用 <a href="https://zh.wikipedia.org/zh-tw/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95">A*</a> 或 <a href="https://zh.wikipedia.org/zh-tw/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">Dijkstra</a> 算法尋找最短路徑。前端使用 Brython 顯示迷宮與路徑。</p>
<p style="padding-left: 60px;">流程:</p>
<p style="padding-left: 90px;">使用 Flask 生成迷宮並計算最短路徑。</p>
<p style="padding-left: 90px;">Flask 將結果回傳給前端。</p>
<p style="padding-left: 90px;">Brython 使用動畫展示機器人如何行走。</p>
<p style="padding-left: 30px;">二、多機器人協作 (Multi-Robot Collaboration)</p>
<p style="padding-left: 60px;">描述: 使用 Flask 後端控制多個機器人的協作，並根據任務分配給各個機器人。在 Brython 前端展示機器人的動態協作。</p>
<p style="padding-left: 60px;">流程:</p>
<p style="padding-left: 90px;">前端傳送多個機器人的初始位置和任務。</p>
<p style="padding-left: 90px;">Flask 計算每個機器人的路徑和協作策略。</p>
<p style="padding-left: 90px;">Brython 以動畫形式展示機器人的動態協作。</p>
<p style="padding-left: 30px;">三、物品搜尋與物品移動</p>
<p style="padding-left: 60px;">描述: 機器人在地圖中搜尋物品，並將其搬移到指定位置。所有搜尋演算法（如深度優先搜尋、廣度優先搜尋）在 Flask 後端運算。</p>
<p style="padding-left: 60px;">流程:</p>
<p style="padding-left: 90px;">Flask 計算搜尋路徑與搬移策略。</p>
<p style="padding-left: 90px;">Brython 顯示動態模擬，並控制機器人移動。</p>
<p style="padding-left: 30px;">四、機器人學習與自適應控制</p>
<p style="padding-left: 60px;">描述: 在 Flask 後端實現強化學習或 Q-learning 演算法，讓機器人學習如何在環境中尋找最優策略。</p>
<p style="padding-left: 60px;">流程:</p>
<p style="padding-left: 90px;">機器人根據前端操作回傳其行為與環境狀態。</p>
<p style="padding-left: 90px;">Flask 訓練機器人並返回最優行為。</p>
<p style="padding-left: 90px;">Brython 實時更新機器人的動作。</p>
<p style="padding-left: 30px;">五、環境變化中的最優路徑規劃</p>
<p style="padding-left: 60px;">描述: 當地圖中有障礙物或其他變化時，機器人需要動態調整路徑。所有路徑規劃的計算在 Flask 後端完成，前端展示機器人的調整過程。</p>
<p style="padding-left: 60px;">流程:</p>
<p style="padding-left: 90px;">Flask 接收環境變化訊息，重新計算最優路徑。</p>
<p style="padding-left: 90px;">Brython 以動畫方式展示機器人根據新的路徑進行調整。</p>
<p>w14-w18: Python (Flask)，Brython，Peewee (ORM)，SQLite</p>
<p style="padding-left: 30px;">Brython 程式環境: </p>
<p style="padding-left: 60px;"><a href="https://s5.eng.nfu.edu.tw:9499/">https://s5.eng.nfu.edu.tw:9499/</a> (部署到 Linux)</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecycu/brython_proj">https://github.com/mdecycu/brython_proj</a> (原始碼)</p>
<p style="padding-left: 30px;">英雄榜: </p>
<p style="padding-left: 60px;"><a href="https://s5.eng.nfu.edu.tw:9498/">https://s5.eng.nfu.edu.tw:9498/</a> (部署到 Linux)</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecycu/cp_final_ex">https://github.com/mdecycu/cp_final_ex</a> (原始碼)</p>
<hr/>
<p>電腦輔助設計室電腦硬體與網路使用介紹</p>
<p style="padding-left: 30px;">C: 為 SSD，網路協定可以自行決定使用 IPv4 或 IPv6 (若使用純 IPv6 則必須設定 Proxy 才能連結到 github.com 以及僅支援 IPv4 協定的網站) </p>
<p>Teams 線上教學:</p>
<p style="padding-left: 30px;">以 "學號@nfu.edu.tw" 登入<span> </span><a href="https://login.microsoftonline.com/">https://login.microsoftonline.com/</a><span> </span>Office 365</p>
<p style="padding-left: 30px;">Teams 團隊代碼: w87x8do</p>
<p>下載可攜程式套件:</p>
<p style="padding-left: 30px;"><a href="http://229.cycu.org/portable_2026.7z">portable_2026.7z</a> (387MB)</p>
<p style="padding-left: 60px;">解開壓縮後，雙點擊 start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。</p>
<p style="padding-left: 60px;">可攜系統啟動後，在命令列執行 conda activate y:\envs\cmsimde 可進入能執行 CMSiMDE 的環境。</p>
<p style="padding-left: 60px;">若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\Scripts\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\Scripts\activate.bat" %Disk%:\envs\cmsimde。</p>
<p>各學員自行<a href="https://docs.github.com/zh/get-started/start-your-journey/creating-an-account-on-github">建立 Github 帳號</a></p>
<p>說明如何建立分組倉儲 Template</p>
<p>學習如何開啟可攜套件、關閉可攜套件</p>
<p style="padding-left: 30px;">利用 Python 執行設計運算及維護倉儲與網站內容</p>
<p style="padding-left: 30px;">Windows <a href="https://hackmd.io/@peterju/B1pUqd-5c">Batch file</a> 與 <a href="https://link.springer.com/book/10.1007/978-1-4842-7064-6">Powershell</a> 應用 </p>
<p><a href="https://classroom.github.com/">Github Classroom</a> 上的分組網站: <a href="https://github.com/mdecp2025">https://github.com/mdecp2025</a> </p>
<p style="padding-left: 30px;"><a href="https://classroom.github.com/">Github Classroom</a> 是一套 Web based 工具，功能在於簡化採用 Github 倉儲進行教學與協同分組的工作 </p>
<p style="padding-left: 30px;">各組組長建立 <a href="https://classroom.github.com/">Github Classroom</a> 分組團隊，各組取得分組倉儲 </p>
<p>學習如何在近端電腦與 <a href="https://github.com/features/codespaces">Codespaces</a> 上維護分組倉儲內容</p>
<p style="padding-left: 30px;">近端: Github Token 與 SSH (Putty、Registry (<a href="https://learn.microsoft.com/zh-tw/troubleshoot/windows-server/performance/windows-registry-advanced-users">中文版</a>、<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users">英文版</a>)應用)  </p>
<p>利用 <a href="https://mde.tw/cp2025/reeborg">Reeborg</a> 學習 Python 基本語法</p>
<hr/>
<h4>計算機程式課程主題總覽</h4>
<h4>課程簡介</h4>
<p>本課程以實作為導向，循序漸進學習 <strong>Python</strong>、<strong>JavaScript</strong>、<strong>HTML</strong>、<strong>CSS</strong> 等現代網頁與程式語言，最終應用於類 <strong><a href="https://mde.tw/reeborg">Reeborg</a> 機器人程式開發</strong>。內容設計結合理論與實作，強調程式邏輯、問題解決與跨語言應用能力。</p>
<ul>
<li>從零基礎學習程式語言的基本結構與語法</li>
<li>掌握網頁技術，為互動式機器人程式設計打下基礎</li>
<li>專題實作，應用於 Reeborg’s World 機器人操作與挑戰任務</li>
</ul>
<h4>課程主題與詳細內容</h4>
<h4>1. Python 基礎與 Reeborg 機器人程式設計</h4>
<ul>
<li><strong>Python 語言簡介：</strong> 特色、應用領域、開發環境介紹</li>
<li><strong>基本語法：</strong> 變數、資料型態、運算子、輸入與輸出</li>
<li><strong>流程控制：</strong> 條件判斷 (<code>if</code>, <code>elif</code>, <code>else</code>)、迴圈 (<code>while</code>, <code>for</code>)</li>
<li><strong>函式與模組：</strong> 函式定義與呼叫、自訂功能、模組導入</li>
<li><strong>Reeborg’s World 操作：</strong>
<ul>
<li>基本指令 (<code>move()</code>, <code>turn_left()</code>, <code>take()</code>, <code>put()</code>)</li>
<li>感測器判斷 (<code>front_is_clear()</code>, <code>wall_in_front()</code>, <code>object_here()</code>, <code>at_goal()</code>)</li>
<li>將 Python 程式邏輯應用於控制機器人走迷宮、撿物、解任務</li>
</ul>
</li>
<li><strong>實作練習：</strong> 關卡挑戰、流程規劃、錯誤偵錯與修正</li>
</ul>
<h4>2. JavaScript 程式設計基礎</h4>
<ul>
<li><strong>JavaScript 角色：</strong> 前端網頁互動語言，與 Python 差異與應用</li>
<li><strong>基本語法：</strong> 變數 (<code>let</code>, <code>const</code>)、資料型態、運算子、輸出 (<code>console.log()</code>)</li>
<li><strong>流程控制：</strong> 條件 (<code>if</code>, <code>else</code>)、迴圈 (<code>for</code>, <code>while</code>)</li>
<li><strong>函式與 ES6 新語法：</strong> 函式宣告、箭頭函式 (<code>() =&gt; {}</code>)</li>
<li><strong>陣列與物件：</strong> 基本操作、方法應用</li>
<li><strong>與網頁互動：</strong> 認識 DOM、事件處理等（為後續進階鋪路）</li>
<li><strong>小專題：</strong> 建立簡單計算機或互動網頁按鈕</li>
</ul>
<h4>3. HTML 基礎 - 建構網頁內容</h4>
<ul>
<li><strong>HTML 結構：</strong> 了解 <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code> 等標籤</li>
<li><strong>常用標籤：</strong> <code>&lt;h1&gt;~&lt;h6&gt;</code> 標題、<code>&lt;p&gt;</code> 段落、<code>&lt;a&gt;</code> 連結、<code>&lt;img&gt;</code> 圖片、<code>&lt;ul&gt;</code>/<code>&lt;ol&gt;</code> 列表、<code>&lt;table&gt;</code> 表格</li>
<li><strong>表單與輸入：</strong> <code>&lt;form&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code> 等</li>
<li><strong>結構化分區：</strong> <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;nav&gt;</code> 等</li>
<li><strong>專案實作：</strong> 製作個人簡歷網頁、Reeborg 世界說明頁等</li>
</ul>
<h4>4. CSS 樣式設計 - 美化網頁版面</h4>
<ul>
<li><strong>CSS 基本語法：</strong> 選擇器、屬性、值的語法結構</li>
<li><strong>常用樣式：</strong> 顏色 (<code>color</code>、<code>background</code>)、字型 (<code>font-size</code>、<code>font-family</code>)、邊框 (<code>border</code>), 間距 (<code>margin</code>, <code>padding</code>)</li>
<li><strong>版面配置：</strong> <code>display</code>、<code>flex</code>、<code>grid</code> 基礎</li>
<li><strong>RWD 響應式設計：</strong> 讓你的網頁適合不同裝置</li>
<li><strong>CSS 與 HTML 整合：</strong> 內嵌樣式、內部樣式表、外部 CSS 檔案</li>
<li><strong>美化 Reeborg 機器人專案網頁：</strong> 實作練習</li>
</ul>
<h4>5. 綜合應用 - Reeborg 機器人專案開發</h4>
<ul>
<li><strong>專案規劃與團隊合作：</strong> 需求分析、分工合作</li>
<li><strong>跨語言整合：</strong> 利用 Python 控制邏輯、JavaScript 增強互動、HTML/CSS 展示結果</li>
<li><strong>打造專屬 Reeborg 世界：</strong> 設計自訂任務與挑戰</li>
<li><strong>成果展示：</strong> 發表與互評，分享學習心得</li>
</ul>
<h4>學習建議與資源</h4>
<ul>
<li>多加練習與嘗試，遇到困難主動討論與尋找資料</li>
<li>推薦學習網站：<a href="https://reeborg.ca/" target="_blank">Reeborg’s World</a>、<a href="https://www.w3schools.com/" target="_blank">W3Schools</a>、<a href="https://developer.mozilla.org/zh-TW/" target="_blank">MDN Web Docs</a></li>
<li>建議每週規劃自主練習與小專案，培養實作與解決問題能力</li>
<li>記錄學習歷程，定期回顧與修正</li>
</ul><h2>Git</h2>
<p>假如您還沒有 Github 帳號，請馬上<a href="https://github.com/signup">建立一個</a>。</p>
<p><span style="background-color: #ffff00;">為何計算機程式課程要使用 Git 與 Github?</span></p>
<p>計算機程式課程（軟體開發）使用 Git 與 GitHub 主要有以下幾個原因：</p>
<ol>
<li>版本控制: Git 是一套分散式的版本控制系統，能記錄每一個檔案的修改歷程。這樣就算不小心改壞了某一個版本的程式，也能隨時回復到以前的版本，而且在協同設計流程中，可以追蹤那一個使用者改了那些內容、什麼時候改的，可以快速釐清許多議題。</li>
<li>團隊協作: 多個開發者可以同時對同一個專案進行開發，透過分支（branch）機制，各自開發新功能、修 bug，最後再合併（merge）到主分支，避免互相覆蓋程式碼。</li>
<li>雲端備份與分享: GitHub 是基於 Git 的雲端代管平台，可以將本地的 Git 專案上傳到雲端，不怕資料遺失。也方便將程式碼公開或私下分享給其他人。</li>
<li>問題追蹤與管理: GitHub 除了儲存程式碼，還提供 issue、pull request 等工具，有助於追蹤 bug、討論功能、審查程式碼，提高專案管理效率。</li>
<li>開放原始碼與社群合作: 許多開放原始碼專案都放在 GitHub，任何人都能貢獻程式碼，促進社群協作與學習。</li>
<li>總結：使用 Git 和 GitHub 可以讓程式開發更有組織、更安全、更容易協作與管理，也方便與他人分享、學習與成長。</li>
</ol>
<p><span style="background-color: #ffff00;">請舉實際的計算機程式開發案例，說明如何操作 Git 與 Github，以便取得程式開發流程的便利與優勢。</span></p>
<p>Git 與 GitHub 操作案例說明</p>
<h4>Git 與 GitHub 實際操作案例：多人開發 ToDo List 網站</h4>
<div>
<h4>1. 專案初始化與上傳</h4>
<div>
<h4><strong>步驟：</strong></h4>
<ol>
<li>在本機建立專案資料夾，初始化 Git：
<pre><code>git init</code></pre>
</li>
<li>新增檔案（如 <code>index.html</code>、<code>app.js</code>），並提交第一個版本：
<pre><code>git add .<br/>git commit -m "Initial commit"</code></pre>
</li>
<li>在 GitHub 建立新 repository，然後將本機專案推送到遠端：
<pre><code>git remote add origin https://github.com/username/todo-app.git<br/>git push -u origin master</code></pre>
</li>
</ol>
<p><strong>優勢：</strong> 所有程式碼都有歷史紀錄，且安全備份於雲端。</p>
</div>
</div>
<div>
<h4>2. 分支開發新功能</h4>
<div>
<p><strong>情境：</strong>小明負責開發「新增待辦事項」功能。</p>
<p><strong>步驟：</strong></p>
<ol>
<li>建立新分支：
<pre><code>git checkout -b feature/add-todo-item</code></pre>
</li>
<li>實作功能並提交：
<pre><code>git add .<br/>git commit -m "Add feature to create todo item"</code></pre>
</li>
<li>推送分支到 GitHub：
<pre><code>git push origin feature/add-todo-item</code></pre>
</li>
</ol>
<p><strong>優勢：</strong> 各自分支開發，互不干擾，降低衝突風險。</p>
</div>
</div>
<div>
<h4>3. Pull Request（合併請求）與 Code Review</h4>
<div class="step">
<p><strong>情境：</strong>小明開發完成，欲合併新功能到主分支。</p>
<p><strong>步驟：</strong></p>
<ol>
<li>在 GitHub 上建立 Pull Request，描述功能內容。</li>
<li>其他團隊成員審查程式碼，提出建議或修正。</li>
<li>經討論無誤後，管理員合併 PR。</li>
</ol>
<p><strong>優勢：</strong> 強化程式品質與團隊溝通，每次合併都有討論紀錄。</p>
</div>
</div>
<div>
<h4>4. 處理 Bug 與 Issue 追蹤</h4>
<div class="step">
<p><strong>情境：</strong>使用者發現「無法刪除待辦事項」的 bug。</p>
<p><strong>步驟：</strong></p>
<ol>
<li>在 GitHub issue 區提出 bug 報告。</li>
<li>團隊分配成員修正，建立 <code>fix/delete-todo-bug</code> 分支。</li>
<li>修正後提交、發 PR、review、合併。</li>
</ol>
<p><strong>優勢：</strong> 所有 bug、功能需求有明確記錄，修正過程透明。</p>
</div>
</div>
<div>
<h4>5. 版本回溯與復原</h4>
<div class="step">
<p><strong>情境：</strong>新功能導致主分支出錯。</p>
<p><strong>步驟：</strong></p>
<ol>
<li>透過 Git log 查找歷史版本：
<pre><code>git log</code></pre>
</li>
<li>回復到上一個穩定版本：
<pre><code>git checkout &lt;commit-id&gt;</code></pre>
</li>
</ol>
<p><strong>優勢：</strong> 不怕程式「改壞」，可隨時回復，輕鬆追蹤誰做了什麼修改。</p>
</div>
</div>
<div>
<h4>總結</h4>
<p>Git 與 GitHub 提供完整的版本控制、團隊協作、問題追蹤、程式碼審查與備份機制，讓開發流程更有條理，大幅提升開發效率與品質。不論團隊或個人開發，都能享有回溯、備份、管理等多重好處。</p>
</div>
<h3>Git_ex1</h3>
<h4>Reeborg 機器人 Python 開發流程與 Git/GitHub 協作範例</h4>
<h4>階段一：基礎 Python 與 Reeborg 指令</h4>
<p>初學者可直接用 Python 撰寫簡單的 <a href="https://mde.tw/cp2025/reeborg/">Reeborg 機器人程式</a>，例如讓機器人向前走數步、左轉、撿物件：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">move()
move()
turn_left()
move()
if object_here():
    take()
</pre>
<h4>階段二：加入函式與三人協同開發</h4>
<div class="collab"><strong>協作情境：</strong>三位組員（A、B、C）各自開發一段行走任務，然後將重複動作寫成函式，合併到專案。</div>
<ol>
<li><strong>組員 A:</strong> 讓機器人前進 3 格
<pre>for i in range(3):
    move()
</pre>
</li>
<li><strong>組員 B:</strong> 機器人轉 2 次左
<pre>for i in range(2):
    turn_left()
</pre>
</li>
<li><strong>組員 C:</strong> 機器人檢查物件並撿取
<pre>if object_here():
    take()
</pre>
</li>
</ol>
<p><span class="tip">協作流程：</span>三人各自建立分支（feature/A, feature/B, feature/C），在 GitHub 上合併 Pull Request，最後由主分支整合。</p>
<h4>Git 基本指令與說明</h4>
<ul>
<li><strong>Step 1：初始化本地倉庫</strong>
<pre>git init
    </pre>
<span>在專案資料夾裡執行，建立 Git 管理的本地倉庫。</span></li>
<li><strong>Step 2：加入遠端 GitHub 倉庫</strong>
<pre>git remote add origin https://github.com/你的帳號或組織/專案名稱.git
    </pre>
<span>將本地倉庫連結到 GitHub 上的遠端 repository。</span></li>
<li><strong>Step 3：建立並切換到功能分支</strong>
<pre>git checkout -b feature/A        # 組員A
git checkout -b feature/B        # 組員B
git checkout -b feature/C        # 組員C
    </pre>
<span>每位組員建立自己的功能分支，分工開發。</span></li>
<li><strong>Step 4：修改程式並加入暫存區</strong>
<pre>git add reeborg.py
    </pre>
<span>將變更過的檔案加入暫存區，準備提交。</span></li>
<li><strong>Step 5：提交更動</strong>
<pre>git commit -m "描述這次開發的內容"
    </pre>
<span>將暫存區的變更提交到本地倉庫。</span></li>
<li><strong>Step 6：推送分支到 GitHub</strong>
<pre>git push -u origin feature/A        # 組員A
git push -u origin feature/B        # 組員B
git push -u origin feature/C        # 組員C
    </pre>
<span>把每個人的分支推到遠端 GitHub。</span></li>
<li><strong>Step 7：建立 Pull Request 並審查合併</strong> <br/> <span>到 GitHub 網站上建立 Pull Request（PR），請其他組員 code review，審查無誤後合併到主分支（main）。</span></li>
<li><strong>Step 8：將最新主分支同步回本地</strong>
<pre>git checkout main
git pull
    </pre>
<span>確保本地 main 跟遠端同步。</span></li>
</ul>
<h4>加入共用函式</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def turn(times):
    for i in range(times):
        turn_left()

def new_move(steps):
    for i in range(steps):
        move()
</pre>
<pre>階段三：重構與加入迴圈、條件與函式應用</pre>
<p>將重複採收動作寫成 <code>harvest_one_row()</code> 函式，結合前進與轉彎，流程更清晰。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def harvest_one_row():
    while object_here():
        take()
    else:
        move()
</pre>
<h4>階段四：導入 class，建立泛用 Reeborg 機器人控制架構</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class ReeborgBot:
    def turn(self, times):
        for i in range(times):
            turn_left()
    def move_steps(self, steps):
        for i in range(steps):
            move()
    def harvest_one_row(self):
        while object_here():
            take()
        else:
            move()
    def harvest_field(self, rows, row_length):
        for i in range(rows):
            for j in range(row_length):
                self.harvest_one_row()
            if i != rows - 1:
                self.turn(3)
                self.move_steps(1)
                self.turn(3)
                self.move_steps(1)

# 使用範例
bot = ReeborgBot()
bot.move_steps(2)
turn_left()
bot.move_steps(2)
bot.harvest_field(3, 6)
</pre>
<pre>協作開發流程與 Git/GitHub 應用摘要</pre>
<ol>
<li><b>git init</b>：建立本地專案。</li>
<li><b>git branch feature/A</b>、<b>git branch feature/B</b>、<b>git branch feature/C</b>：三位組員各自建立分支（或用 <b>git checkout -b</b> 一次完成）。</li>
<li><b>git add</b>、<b>git commit</b>、<b>git push</b>：將各自更動上傳到 GitHub。</li>
<li><b>Pull Request</b>：在 GitHub 建立 PR，進行 code review 與合併。</li>
<li>遇重複邏輯，抽象為函式，用新分支推送與合併。</li>
<li>最後導入 class，建立泛用控制架構，提升可維護性與擴充性。</li>
</ol>
<h4>結語</h4>
<p>本例展示 Python 基礎語法、函式、類別應用，以及如何善用 Git/GitHub 進行協同開發，讓團隊程式碼更有架構、易於管理與擴展。</p>
<h3>Git_ex2</h3>
<h4>三人協同開發 Reeborg 程式：Git/GitHub 詳細流程與指令</h4>
<h4>專案設計演進與協作分工</h4>
<ol>
<li><b>階段一：初始設計（三人各自撰寫基本功能）</b>
<ul>
<li>Alice：負責機器人移動與左轉基本動作</li>
<li>Bob：設計撿取物件的邏輯</li>
<li>Carol：設計主程式流程與方向判斷</li>
</ul>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># Alice
move()
move()
turn_left()
move()

# Bob
if object_here():
    take()

# Carol
while not is_facing_north():
    turn_left()
    </pre>
<p><b>git 指令：</b></p>
<ul>
<ul>
<li>三人各自建立分支並上傳初步程式片段</li>
</ul>
</ul>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git checkout -b feature/move  # Alice
git checkout -b feature/take  # Bob
git checkout -b feature/dir   # Carol

git add reeborg.py
git commit -m "初步功能"
git push -u origin feature/move  # Alice
git push -u origin feature/take  # Bob
git push -u origin feature/dir   # Carol</pre>
</li>
<li><b>階段二：重複迴圈設計（逐步將動作包裝為迴圈）</b>
<ul>
<li>Alice：將移動與轉向包裝進 for 迴圈</li>
<li>Bob：將撿取物件行為放入 while 迴圈</li>
</ul>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># Alice
for i in range(3):
    move()

for i in range(2):
    turn_left()

# Bob
while object_here():
    take()
    </pre>
<p><b>git 指令：</b></p>
<ul>
<ul>
<li>各自於分支更新程式並提交</li>
</ul>
</ul>
<pre>git add reeborg.py
git commit -m "加入重複迴圈"
git push
      </pre>
</li>
<li><b>階段三：Function 封裝設計（將重複邏輯抽象為函式）</b>
<ul>
<li>Alice：設計 <code>new_move</code>、<code>turn</code>、<code>turn_right</code></li>
<li>Bob：設計 <code>harvest_one_row</code>，用 global 記錄物件數</li>
<li>Carol：設計 <code>is_facing_east</code> 與主流程</li>
</ul>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def turn(n):
    for i in range(n):
        turn_left()

def turn_right():
    for i in range(3):
        turn_left()

def new_move(n):
    for i in range(n):
        move()

def harvest_one_row():
    global object_taken
    while object_here() and object_taken &lt; 36:
        take()
        object_taken += 1
    if object_taken &lt; 36:
        move()

def is_facing_east():
    count = 0
    while not is_facing_north():
        turn_left()
        count += 1
        if count == 4:
            break
    turn(3)
    return True
    </pre>
<p><b>git 指令：</b></p>
<ul>
<ul>
<li>各自於分支完成函式開發</li>
</ul>
</ul>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git add reeborg.py
git commit -m "完成 function 封裝"
git push</pre>
</li>
<li><b>階段四：導入 class-based 設計（最終彈性架構）</b>
<ul>
<li>Alice、Bob、Carol 協作將函式整合為 class，提升可維護性</li>
</ul>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class ReeborgBot:
    def __init__(self):
        self.object_taken = 0

    def turn(self, n):
        for i in range(n):
            turn_left()
    
    def turn_right(self):
        for i in range(3):
            turn_left()

    def new_move(self, n):
        for i in range(n):
            move()
    
    def harvest_one_row(self):
        while object_here() and self.object_taken &lt; 36:
            take()
            self.object_taken += 1
        if self.object_taken &lt; 36:
            move()
    
    def is_facing_east(self):
        count = 0
        while not is_facing_north():
            turn_left()
            count += 1
            if count == 4:
                break
        self.turn(3)
        return True

    def harvest_field(self):
        self.new_move(2)
        self.turn(1)
        self.new_move(2)
        done = False
        while self.is_facing_east() and not done:
            for _ in range(2):
                for _ in range(6):
                    self.harvest_one_row()
                    if self.object_taken &gt;= 36:
                        done = True
                        break
                if done: break
                for _ in range(2):
                    self.turn(1)
                    move()
                for _ in range(6):
                    self.harvest_one_row()
                    if self.object_taken &gt;= 36:
                        done = True
                        break
                if done: break
                for _ in range(2):
                    self.turn_right()
                    move()
            if self.object_taken &gt;= 36:
                print("task completed!")
                break

# 使用範例
bot = ReeborgBot()
bot.harvest_field()
    </pre>
<p><b>git 指令：</b></p>
<ul>
<ul>
<li>協作於 feature/class-based 分支整合 class 架構</li>
</ul>
</ul>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git checkout -b feature/class-based
# 合併 Alice/Bob/Carol 分支或直接在此分支重構
git add reeborg.py
git commit -m "整合 class-based 架構"
git push -u origin feature/class-based</pre>
</li>
</ol>
<h4>專案開發分工摘要表</h4>
<table>
<tbody>
<tr>
<th>組員</th>
<th>負責內容</th>
<th>Git 分支名稱</th>
</tr>
<tr>
<td>Alice</td>
<td>基本移動與轉向（<code>new_move</code>、<code>turn</code>、<code>turn_right</code>）</td>
<td>feature/move-turn</td>
</tr>
<tr>
<td>Bob</td>
<td>收成邏輯（<code>harvest_one_row</code>、<code>object_taken</code>）</td>
<td>feature/harvest</td>
</tr>
<tr>
<td>Carol</td>
<td>方向判斷與主流程（<code>is_facing_east</code>、主執行流程）</td>
<td>feature/main-loop</td>
</tr>
</tbody>
</table>
<h4>GitHub 操作 Step by Step</h4>
<ol>
<li><b>由一位組員（如 Alice）新建 repo</b>（如 <code>reeborg-harvest</code>）</li>
<li><b>本地初始化：</b>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git clone https://github.com/your-org/reeborg-harvest.git
cd reeborg-harvest</pre>
</li>
<li><b>建立主分支 main：</b>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git checkout -b main
git push -u origin main</pre>
</li>
<li><b>三位組員各自分出功能分支：</b>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git checkout -b feature/move-turn      # Alice
git checkout -b feature/harvest        # Bob
git checkout -b feature/main-loop      # Carol</pre>
</li>
<li><b>推送分支到遠端：</b>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git push -u origin feature/move-turn      # Alice
git push -u origin feature/harvest        # Bob
git push -u origin feature/main-loop      # Carol</pre>
</li>
<li><b>組員於各自分支開發程式並提交：</b>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git add reeborg.py
git commit -m "功能/重構/修正說明"
git push</pre>
</li>
<li><b>建立 Pull Request（PR）並 Code Review：</b>
<ul>
<li>於 GitHub 建立 PR，標明合併分支、審查人員、功能說明</li>
<li>進行 code review，提出建議與修正</li>
<li>審查通過後合併 PR（Merge pull request）</li>
</ul>
</li>
<li><b>main 分支同步至本地：</b>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git checkout main
git pull</pre>
</li>
</ol>
<h4>後續協作建議</h4>
<ul>
<ul>
<li>每次新增功能或修正前，請先拉新分支，勿直接在 main 分支作業：</li>
</ul>
</ul>
<pre>git checkout -b feature/新功能</pre>
<ul>
<ul>
<li>合併前先同步主分支，解決衝突後再 push：</li>
</ul>
</ul>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git pull origin main
# 如有衝突，解決後再
git add .
git commit -m "解決衝突"
git push</pre>
<ul>
<li>在 Pull Request 詳細描述修改內容與測試方式，方便審查。</li>
<li>善用 <code>git log</code>、<code>git status</code>、<code>git diff</code> 檢查歷史與變更。</li>
</ul>
<h4>常用 Git 指令說明</h4>
<ul>
<li><code>git checkout -b 分支名</code>：從目前分支新建並切換到分支</li>
<li><code>git add 檔名</code>：加入暫存區，準備提交</li>
<li><code>git commit -m "訊息"</code>：提交更動，寫下本次修改說明</li>
<li><code>git push -u origin 分支名</code>：推送分支到遠端</li>
<li><code>git pull</code>：拉下遠端最新更動並合併</li>
<li><code>git merge 分支名</code>：將指定分支合併到目前分支</li>
<li><code>git status</code>：顯示目前狀態、尚未提交的變更</li>
<li><code>git log</code>：查詢提交歷史</li>
<li><code>git diff</code>：顯示檔案內容變更差異</li>
</ul>
<h4>結論</h4>
<p>本範例展現 Reeborg 機器人從最簡單設計、逐步進化至 class-based 架構的過程，以及三人協同開發的 Git/GitHub 分支工作流。遵循此流程能大幅提升團隊協作、程式碼品質與可維護性。</p>
<h2>Python</h2>
<p>可攜程式套件:</p>
<p style="padding-left: 30px;"><a href="http://229.cycu.org/portable_2026.7z">portable_2026.7z</a> (387MB)</p>
<p style="padding-left: 60px;">解開壓縮後，雙點擊 start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。</p>
<p style="padding-left: 60px;">可攜系統啟動後，在命令列執行 <span style="background-color: #ccffcc;">conda activate y:\envs\cmsimde</span> 可進入能執行 CMSiMDE 的環境。</p>
<p style="padding-left: 60px;">若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\Scripts\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\Scripts\activate.bat" %Disk%:\envs\cmsimde。</p>
<p>cmsimde 虛擬環境是採下列方式建立:</p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">conda create -p ./envs/cmsimde python=3.13</span> (指定使用 Python 3.13 建立位於 ./envs/cmsimde 的虛擬環境)</p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">conda activate y:\envs\cmsimde</span> (利用 conda 指令切換到 cmsimde 虛擬環境)</p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">conda install -c conda-forge flask flask_cors bs4 lxml pelican markdown gevent</span> (安裝使用 cmsimde 所需要的 Python 模組)</p>
<p style="padding-left: 30px;">之後就可以 cd tmp/your_hw_repository 後，以 cms 批次檔案指令啟動網頁編輯。</p>
<hr/>
<p>Learn Python with <a href="https://mde.tw/reeborg">Reeborg</a></p>
<p style="padding-left: 30px;"><a href="https://reeborg.ca/docs/en/">https://reeborg.ca/docs/en/</a></p>
<p style="padding-left: 30px;"><a href="https://aroberge.gitbooks.io/reeborg-s-world-advanced-world-creation/content/">https://aroberge.gitbooks.io/reeborg-s-world-advanced-world-creation/content/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/loukhin/Reeborg">https://github.com/loukhin/Reeborg</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/aroberge/reeborg-howto">https://github.com/aroberge/reeborg-howto</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/LeeRenJie/100-days-of-code-in-python">https://github.com/LeeRenJie/100-days-of-code-in-python</a></p>
<p style="padding-left: 30px;"><a href="http://repo.darmajaya.ac.id/4765/1/The%20Self-Taught%20Programmer_%20The%20Definitive%20Guide%20to%20Programming%20Professionally%20%28%20PDFDrive%20%29.pdf">Self-taught programmer</a></p>
<p>Python code for Artificial Intelligence - Foundations of Computational Agents</p>
<p style="padding-left: 30px;"><a href="https://artint.info/AIPython/aipython.pdf">https://artint.info/AIPython/aipython.pdf</a></p>
<p style="padding-left: 30px;"><a href="https://www.researchgate.net/publication/387024839_Programming_AI_with_Python">Program AI with Python</a></p>
<p style="padding-left: 30px;"><a href="https://www.tutorialspoint.com/artificial_intelligence_with_python/artificial_intelligence_with_python_tutorial.pdf">AI with Python</a></p>
<p style="padding-left: 30px;"><a href="https://web.stanford.edu/class/archive/cs/cs106a/cs106a.1208/lectures/26-Intro-to-AI/26-Intro-to-AI.pdf">Using Python for Artificial Intelligence</a></p>
<p style="padding-left: 30px;"><a href="https://python-course.eu/books/bernd_klein_python_and_machine_learning_a4.pdf">Machine Learning with Python Tutorial</a></p>
<p>Genetic Algorithms:</p>
<p style="padding-left: 30px;"><a href="/downloads/GA/ga_1.py">ga_1.py</a> (from <a href="https://www.geeksforgeeks.org/genetic-algorithms/">https://www.geeksforgeeks.org/genetic-algorithms/</a>)</p>
<p style="padding-left: 30px;"><a href="https://medium.com/analytics-vidhya/genetic-algorithm-494ac5be18bb">https://medium.com/analytics-vidhya/genetic-algorithm-494ac5be18bb</a></p>
<p style="padding-left: 30px;"><a href="https://medium.com/@LeonFedden/evolving-solutions-with-genetic-algorithms-e3122473a35f">https://medium.com/@LeonFedden/evolving-solutions-with-genetic-algorithms-e3122473a35f</a></p>
<p style="padding-left: 30px;">Apply GA to <a href="https://github.com/mdecycu/cs101">https://github.com/mdecycu/cs101</a></p>
<h3>SE</h3>
<p>順序控制 (Sequential Execution)</p>
<p>最基本的程式執行方式，命令依序執行。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 範例 1：向前走三步
move()
move()
move()

# 範例 2：走一步後左轉
move()
turn_left()

# 範例 3：走一步、撿物品、左轉
move()
take()
turn_left()</pre>
<h3>CL</h3>
<p>條件判斷（Conditional Logic)</p>
<p>根據環境狀況做出不同的動作。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 範例 1：如果前方有牆就左轉
if wall_in_front():
    turn_left()

# 範例 2：如果有物品就撿起來
if object_here():
    take()

# 範例 3：如果前方沒牆就前進，否則左轉
if not wall_in_front():
    move()
else:
    turn_left()</pre>
<p></p>
<h3>Loops</h3>
<p>迴圈（Loops）<br/>重複執行某些動作直到條件不成立。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 範例 1：走到牆前
while not wall_in_front():
    move()

# 範例 2：撿起所有物品
while object_here():
    take()

# 範例 3：走到底並每格放一個物品
while not wall_in_front():
    put()
    move()</pre>
<h3>Recursion</h3>
<p>遞迴（Recursion）<br/>用函式自己呼叫自己來處理重複任務。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 範例 1：走到底（遞迴版）
def walk():
    if not wall_in_front():
        move()
        walk()

walk()

# 範例 2：撿起所有物品（遞迴版）
def pick_all():
    if object_here():
        take()
        pick_all()

pick_all()

# 範例 3：探索迷宮（簡化遞迴）
def explore():
    if not wall_in_front():
        move()
        explore()
    else:
        turn_left()
        explore()

explore()</pre>
<h3>SA</h3>
<p>搜尋演算法（Search Algorithms）<br/>用 DFS 或 BFS 的邏輯探索迷宮。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 範例 1：DFS 探索（深度優先）
def dfs():
    for i in range(4):
        if not wall_in_front():
            move()
            dfs()
            turn_left()
            turn_left()
            move()
            turn_left()
            turn_left()
        turn_left()

dfs()

# 範例 2：BFS 模擬（需額外結構支援）
# Reeborg 不支援 queue，但可模擬 BFS 的層級探索

# 範例 3：探索直到找到物品
def search():
    if object_here():
        take()
        return
    for i in range(4):
        if not wall_in_front():
            move()
            search()
            turn_left()
            turn_left()
            move()
            turn_left()
            turn_left()
        turn_left()

search()</pre>
<p>深入探討 BFS（廣度優先搜尋）在 Reeborg 世界的模擬方式！雖然 Reeborg 不支援真正的 queue 結構，但我們可以透過層級探索的邏輯來模擬 BFS 的行為。以下是三個範例，每個都展示如何在 Reeborg 的限制下模擬 BFS 的層級探索：</p>
<p>範例 1：探索四個方向（模擬 BFS 的鄰接節點）<br/>這個範例模擬 BFS 的「一層一層探索」概念，先嘗試所有方向再深入。</p>
<p>這段程式碼會嘗試探索機器人周圍的四個方向，每次都回到原點，模擬 BFS 的「同層探索」。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def explore_level():
    for i in range(4):  # 嘗試四個方向
        if not wall_in_front():
            move()
            # 模擬記錄節點（可加上 take() 或其他動作）
            turn_left()
            turn_left()
            move()  # 回到原點
            turn_left()
            turn_left()
        turn_left()

explore_level()</pre>
<p>範例 2：探索並記錄層級（模擬 BFS 的層級記憶）<br/>這個範例加入層級變數，模擬 BFS 的層級控制。</p>
<p>這段程式碼會探索所有第一層的方向，然後對每個方向再探索下一層，模擬 BFS 的層級展開。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def bfs_level(depth):
    if depth == 0:
        return
    for i in range(4):
        if not wall_in_front():
            move()
            bfs_level(depth - 1)  # 探索下一層
            turn_left()
            turn_left()
            move()  # 回到原點
            turn_left()
            turn_left()
        turn_left()

bfs_level(2)  # 探索兩層深度</pre>
<p>範例 3：尋找物品（模擬 BFS 的目標搜尋）<br/>這個範例模擬 BFS 尋找目標（例如物品），並在找到後停止。</p>
<p>這段程式碼模擬 BFS 尋找物品的過程，並在找到目標後停止探索。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">found = False

def bfs_search(depth):
    global found
    if depth == 0 or found:
        return
    for i in range(4):
        if not wall_in_front():
            move()
            if object_here():
                take()
                found = True
                return
            bfs_search(depth - 1)
            if not found:
                turn_left()
                turn_left()
                move()
                turn_left()
                turn_left()
        turn_left()

bfs_search(3)  # 最多探索三層深度</pre>
<p>以上這些範例雖然不是真正的 BFS（因為缺乏 queue 與 visited 記錄），但已經能在 Reeborg 的限制下模擬「層級探索」的核心概念。</p>
<h3>SST</h3>
<p>模擬與狀態追蹤（Simulation &amp; State Tracking）<br/>追蹤機器人狀態或環境變化。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 範例 1：記錄走過的格子數
steps = 0
while not wall_in_front():
    move()
    steps += 1

# 範例 2：模擬方向轉動
def turn_right():
    for _ in range(3):
        turn_left()

# 範例 3：模擬狀態機（簡化）
state = "searching"
while state != "done":
    if object_here():
        take()
        state = "done"
    else:
        move()</pre>
<h3>Maze</h3>
<p>解迷宮（探索與回溯）<br/>用回溯法探索並回到起點。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 範例 1：探索並回溯
def solve():
    for i in range(4):
        if not wall_in_front():
            move()
            solve()
            turn_left()
            turn_left()
            move()
            turn_left()
            turn_left()
        turn_left()

solve()</pre>
<h3>Collect</h3>
<p>收集物品並排序（模擬排序演算法）<br/>雖然 Reeborg 不支援陣列，但可模擬排序邏輯。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 範例 1：模擬選擇排序（假設物品代表數值）
# 這部分需創造任務場景，例如物品代表大小

# 範例 2：依序撿起並放置（模擬排序）
while object_here():
    take()
    move()
    put()

# 範例 3：模擬交換位置
# 假設兩格有物品，交換位置
take()
move()
take()
turn_left()
turn_left()
move()
put()
turn_left()
turn_left()
move()
put()</pre>
<h3>GT</h3>
<p>Graph Theory</p>
<p>建構地圖或路徑（圖論基礎）<br/>模擬圖的節點與邊，探索所有可能路徑。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 範例 1：探索所有方向（模擬圖的鄰接節點）
for i in range(4):
    if not wall_in_front():
        move()
        # 模擬記錄節點
        turn_left()
        turn_left()
        move()
        turn_left()
        turn_left()
    turn_left()

# 範例 2：記錄路徑（用清單模擬）
path = []
while not wall_in_front():
    move()
    path.append("forward")

# 範例 3：模擬圖的 DFS
def dfs_graph():
    for i in range(4):
        if not wall_in_front():
            move()
            dfs_graph()
            turn_left()
            turn_left()
            move()
            turn_left()
            turn_left()
        turn_left()

dfs_graph()</pre>
<p></p>
<h3>Python_ex1</h3>
<h4>Python 初學者學習指引</h4>
<h4>一、學習步驟建議</h4>
<ol>
<li>認識 Python 的應用與特色。</li>
<li>選擇合適的學習平台: <a href="https://mde.tw/reeborg/">https://mde.tw/reeborg/</a>。</li>
<li>熟悉 Python 的基本語法與執行方式。</li>
<li>從簡單題目逐步挑戰更進階的練習。</li>
<li>多做實作練習，並觀察程式執行結果。</li>
</ol>
<h4>二、Python 必學基本語法</h4>
<ul>
<li><strong>變數與資料型態：</strong>
<pre><code>x = 10
name = "Alice"
is_ok = True</code></pre>
</li>
<li><strong>輸出：</strong>
<pre><code>print("Hello, world!")</code></pre>
</li>
<li><strong>運算子：</strong>
<ul>
<li>數學運算：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>//</code>、<code>%</code></li>
<li>比較運算：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code></li>
<li>邏輯運算：<code>and</code>、<code>or</code>、<code>not</code></li>
</ul>
</li>
<li><strong>條件判斷：</strong>
<pre><code>if x &gt; 0:
    print("正數")
else:
    print("非正數")</code></pre>
</li>
<li><strong>迴圈：</strong>
<pre><code>while 條件:
    # 重複執行內容
</code></pre>
</li>
<li><strong>函式：</strong>
<pre><code>def greet():
    print("Hi!")</code></pre>
</li>
<li><strong>縮排與註解：</strong>
<pre><code># 這是註解
if True:
    print("這行有縮排")</code></pre>
</li>
</ul>
<h4>三、Reeborg’s World 學習重點</h4>
<ul>
<li><strong>基本指令：</strong>
<ul>
<li><code>move()</code>：前進一格</li>
<li><code>turn_left()</code>：左轉</li>
<li><code>take()</code>：撿起物品</li>
<li><code>put()</code>：放下物品</li>
</ul>
</li>
<li><strong>感測與判斷：</strong>
<ul>
<li><code>front_is_clear()</code>：前方有路</li>
<li><code>wall_in_front()</code>：前方有牆</li>
<li><code>object_here()</code>：目前格子有物品</li>
</ul>
</li>
<li><strong>條件與迴圈應用：</strong>
<pre><code>if front_is_clear():
    move()
else:
    turn_left()

while not at_goal():
    move()</code></pre>
</li>
<li><strong>自訂函式：</strong>
<pre><code>def turn_right():
    turn_left()
    turn_left()
    turn_left()</code></pre>
</li>
</ul>
<h4>四、小結</h4>
<ul>
<li>先學會基本語法與程式邏輯，再用 Reeborg 練習解題。</li>
<li>多做題目，觀察執行結果與錯誤訊息，提升解決問題能力。</li>
<li>熟悉條件判斷、迴圈、函式，是學好 Python 的基礎。</li>
</ul>
<hr/>
<h4>Python 初學者超詳細學習指引<br/><small>（以 Reeborg 機器人練習為例）</small></h4>
<h4>一、Python 學習流程與心法</h4>
<ol>
<li><strong>認識 Python</strong>
<ul>
<li>Python 是一種簡潔、易讀、用途廣泛的程式語言。</li>
<li>常用於資料分析、人工智慧、網頁開發、自動化等領域。</li>
<li>學好基礎語法，日後可延伸應用到許多不同領域。</li>
</ul>
</li>
<li><strong>選擇學習工具</strong>
<ul>
<li>初學推薦 <a href="https://mde.tw/reeborg/">https://mde.tw/reeborg/</a>，直接練習程式，免安裝。</li>
<li>也可用 Python 官方網站下載安裝，或用線上編輯器（如 repl.it、Google Colab）。</li>
</ul>
</li>
<li><strong>循序漸進學習</strong>
<ul>
<li>先熟悉「變數、運算子、條件、迴圈、函式」等核心語法。</li>
<li>搭配 Reeborg 關卡，練習邏輯與解題。</li>
<li>寫程式要勇於嘗試與修正，錯誤是學習的起點！</li>
</ul>
</li>
<li><strong>主動多練習、多觀察、多思考</strong>
<ul>
<li>練習題目與挑戰，能讓你熟悉語法、訓練邏輯。</li>
<li>觀察程式執行過程與錯誤訊息，學會除錯（debug）。</li>
<li>遇到卡關時，試著將問題拆解成小步驟。</li>
</ul>
</li>
</ol>
<h4>二、Python 基本語法說明與範例</h4>
<table>
<tbody>
<tr>
<th>語法主題</th>
<th>說明</th>
<th>範例</th>
</tr>
<tr>
<td>變數</td>
<td>儲存資料（數字、文字、布林值等）</td>
<td><code>x = 5<br/>name = "Tom"<br/>is_ok = True</code></td>
</tr>
<tr>
<td>資料型態</td>
<td>整數 <code>int</code>、小數 <code>float</code>、字串 <code>str</code>、布林 <code>bool</code></td>
<td><code>a = 7<br/>b = 3.14<br/>c = "Hello"<br/>d = False</code></td>
</tr>
<tr>
<td>輸出</td>
<td>用 <code>print()</code> 顯示資訊</td>
<td><code>print("Hello world!")<br/>print(x + 2)</code></td>
</tr>
<tr>
<td>運算子</td>
<td>數學、比較、邏輯運算</td>
<td><code> # 數學<br/> y = x + 1<br/> # 比較<br/> x &gt; 3<br/> # 邏輯<br/> True and False </code></td>
</tr>
<tr>
<td>條件判斷</td>
<td>根據條件執行不同程式碼</td>
<td><code> if x &gt; 0:<br/>   print("正數")<br/> else:<br/>   print("負數或零") </code></td>
</tr>
<tr>
<td>迴圈 (while)</td>
<td>重複執行，直到條件不成立</td>
<td><code> count = 0<br/> while count &lt; 3:<br/>   print(count)<br/>   count += 1 </code></td>
</tr>
<tr>
<td>for 迴圈（了解即可）</td>
<td>依序處理序列資料</td>
<td><code> for i in range(5):<br/>   print(i) </code></td>
</tr>
<tr>
<td>函式</td>
<td>將重複動作打包，方便重用</td>
<td><code> def say_hello():<br/>   print("Hello!")<br/> say_hello() </code></td>
</tr>
<tr>
<td>縮排與註解</td>
<td>Python 用縮排分區塊，註解用 <code>#</code></td>
<td><code> # 這是註解<br/> if True:<br/>   print("有縮排") </code></td>
</tr>
</tbody>
</table>
<div class="tip"><strong>小提醒：</strong> Python 不用分號，且縮排必須統一（通常 4 個空格）。</div>
<h4>三、Reeborg's World 機器人操作重點</h4>
<ul>
<li><strong>基本指令</strong>
<ul>
<li><code>move()</code>：前進一格</li>
<li><code>turn_left()</code>：左轉 90 度</li>
<li><code>take()</code>：撿起物品</li>
<li><code>put()</code>：放下物品</li>
</ul>
</li>
<li><strong>判斷世界狀態的感測器</strong>
<ul>
<li><code>front_is_clear()</code>：前方有路</li>
<li><code>wall_in_front()</code>：前方有牆</li>
<li><code>right_is_clear()</code>：右方有路</li>
<li><code>wall_on_right()</code>：右方有牆</li>
<li><code>object_here()</code>：目前格子有物品</li>
<li><code>at_goal()</code>：到達終點</li>
</ul>
</li>
<li><strong>條件判斷/迴圈應用</strong>
<pre><code>
if front_is_clear():
    move()
else:
    turn_left()

while not at_goal():
    move()
                </code></pre>
</li>
<li><strong>自訂函式（提升可讀性與重用）</strong>
<pre><code>
def turn_right():
    for i in range(3):
        turn_left()

def pick_and_move():
    take()
    move()

# 呼叫自訂函式
turn_right()
                </code></pre>
</li>
<li><strong>解題流程建議</strong>
<ol>
<li>仔細閱讀題目與世界設定。</li>
<li>思考機器人要完成哪些步驟（可先畫流程圖）。</li>
<li>將步驟拆解成小動作，分別寫成程式。</li>
<li>適時用 <code>if</code> 或 <code>while</code> 控制流程。</li>
<li>多嘗試、多觀察，多用 print 或步步執行除錯。</li>
</ol>
</li>
</ul>
<div class="warning"><strong>常見錯誤：</strong>
<ul>
<li>少寫小括號（如 <code>move</code> 寫成 <code>move()</code>）。</li>
<li>縮排錯誤導致語法錯。</li>
<li>無窮迴圈（如 while 條件永遠為真）。</li>
</ul>
</div>
<h4>四、進階建議與常見問題</h4>
<ul>
<li><strong>多加練習</strong>
<ul>
<li>完成 <a href="https://mde.tw/reeborg/">https://mde.tw/reeborg/</a> 的所有世界（關卡）。</li>
<li>嘗試設計自己的世界與題目。</li>
</ul>
</li>
<li><strong>閱讀程式碼，互相學習</strong>
<ul>
<li>觀摩別人解法，了解不同邏輯。</li>
<li>勇於提問與討論（如參加線上社群）。</li>
</ul>
</li>
<li><strong>養成良好習慣</strong>
<ul>
<li>適當註解，提高可讀性。</li>
<li>命名有意義的變數與函式。</li>
</ul>
</li>
</ul>
<h4>五、完整學習流程小結</h4>
<ol>
<li>學會 Python 基本文法、邏輯思考。</li>
<li>熟練 <a href="https://mde.tw/reeborg/">https://mde.tw/reeborg/</a> 指令、感測器、流程控制。</li>
<li>多練習、多觀察、多修正。</li>
<li>培養拆解問題、設計函式的能力。</li>
<li>主動探索更多應用與進階技巧。</li>
</ol>
<h2>Javascript</h2>
<h4>JavaScript 初學者完整學習指引</h4>
<h4>一、為什麼學 JavaScript？</h4>
<ul>
<li>JavaScript 是網頁開發必學語言，執行於所有主流瀏覽器。</li>
<li>可用於前端（瀏覽器）、後端（Node.js）、行動應用、桌面應用等。</li>
<li>社群大、資源多，學會 JS 等於打開 Web 世界大門。</li>
</ul>
<h4>二、學習流程建議</h4>
<ol>
<li>認識 JavaScript 應用場景及基礎語法。</li>
<li>熟悉開發與測試環境：<br/>推薦直接在 Chrome、Edge、Firefox 等瀏覽器按 F12 開啟「開發人員工具」→「主控台(Console)」練習。</li>
<li>循序漸進學習語法與邏輯：從變數、流程控制、函式、物件等開始。</li>
<li>多做練習題與小專案。</li>
<li>了解 DOM 操作、事件處理與基礎網頁互動。</li>
<li>進階可學習 ES6+ 新語法與框架（如 React、Vue）。</li>
</ol>
<h4>三、JavaScript 必學基礎語法與範例</h4>
<table>
<tbody>
<tr>
<th>語法主題</th>
<th>說明</th>
<th>範例</th>
</tr>
<tr>
<td>變數宣告</td>
<td>用 <code>let</code>、<code>const</code>（現代 JS），<br/>不要再用 <code>var</code>。</td>
<td><code>let x = 10;<br/>const pi = 3.14;</code></td>
</tr>
<tr>
<td>資料型態</td>
<td>數字（Number）、字串（String）、布林（Boolean）、陣列（Array）、物件（Object）、null、undefined</td>
<td><code> let s = "hi";<br/> let arr = [1,2,3];<br/> let person = { name: "Tom", age: 20 }; </code></td>
</tr>
<tr>
<td>輸出</td>
<td>用 <code>console.log()</code> 輸出到主控台</td>
<td><code>console.log("Hello!");<br/>console.log(x + 2);</code></td>
</tr>
<tr>
<td>運算子</td>
<td>數學（+、-、*、/、%）、比較（==、===、!=、!==、&gt;、&lt;）、邏輯（&amp;&amp;、||、!）</td>
<td><code> let z = x + 5;<br/> x === 10<br/> (a &gt; 0) &amp;&amp; (b &lt; 5) </code></td>
</tr>
<tr>
<td>條件判斷</td>
<td>if、else if、else</td>
<td><code> if (x &gt; 0) {<br/>   console.log("正數");<br/> } else {<br/>   console.log("非正數");<br/> } </code></td>
</tr>
<tr>
<td>迴圈</td>
<td>for、while、do...while</td>
<td><code> for (let i = 0; i &lt; 3; i++) {<br/>   console.log(i);<br/> }<br/> <br/> let count = 0;<br/> while (count &lt; 3) {<br/>   console.log(count);<br/>   count++;<br/> } </code></td>
</tr>
<tr>
<td>函式</td>
<td>定義與呼叫，<br/> ES6 支援箭頭函式</td>
<td><code> function greet(name) {<br/>   console.log("Hi, " + name);<br/> }<br/> greet("Amy");<br/> <br/> // 箭頭函式<br/> const add = (a, b) =&gt; a + b;<br/> console.log(add(2,3)); </code></td>
</tr>
<tr>
<td>陣列與物件</td>
<td>基本操作：存取元素、方法如 <code>push</code>、<code>forEach</code> 等</td>
<td><code> let nums = [1,2,3];<br/> nums.push(4);<br/> nums.forEach(item =&gt; console.log(item));<br/> <br/> let person = { name: "Tom", age: 20 };<br/> console.log(person.name); </code></td>
</tr>
<tr>
<td>註解</td>
<td>單行 <code>//</code>，多行 <code>/* */</code></td>
<td><code> // 這是單行註解<br/> /*<br/> 這是多行註解<br/> */ </code></td>
</tr>
</tbody>
</table>
<div class="tip"><strong>小提醒：</strong> JavaScript 語法彈性大，但容易出現隱含錯誤，建議使用嚴格模式 <code>'use strict';</code>，養成良好命名與註解習慣。</div>
<h4>四、在網頁上的應用簡介</h4>
<ul>
<li>JavaScript 主要用於網頁互動、動態內容與事件處理。</li>
<li>可透過 <code>&lt;script&gt;</code> 標籤直接在 HTML 內嵌或引用外部 JS 檔案：</li>
</ul>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;JS 範例&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;button onclick="sayHello()"&gt;點我&lt;/button&gt;
  &lt;script&gt;
    function sayHello() {
      alert("你好！");
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h4>五、常見錯誤與學習建議</h4>
<ul>
<li><strong>常見錯誤：</strong>
<ul>
<li>少分號或括號（雖然 JS 支援自動補全，但還是建議加上）。</li>
<li>變數未宣告直接使用。</li>
<li>區分 <code>==</code>（寬鬆相等）與 <code>===</code>（嚴格相等）。</li>
<li>陣列與物件存取語法錯誤。</li>
</ul>
</li>
<li><strong>學習建議：</strong>
<ul>
<li>多練習：在主控台嘗試各種語法。</li>
<li>閱讀 MDN（Mozilla Developer Network）文件，查詢 JS 語法與用法。</li>
<li>完成小專案，如計算機、Todo List、網頁互動等。</li>
<li>多與他人討論，參加線上社群。</li>
</ul>
</li>
</ul>
<h4>六、進階主題（可視情況逐步學習）</h4>
<ul>
<li>ES6+ 新語法（let、const、箭頭函式、解構賦值、展開運算子、模組化等）</li>
<li>事件處理、DOM 操作與網頁互動</li>
<li>非同步程式（callback、Promise、async/await）</li>
<li>物件導向程式設計、類別（class）</li>
<li>前端框架（如 React、Vue、Angular）</li>
<li>Node.js 伺服器端開發</li>
</ul>
<h3>HTML and CSS</h3>
<h4>HTML &amp; CSS 初學者學習指南</h4>
<h4>一、HTML 與 CSS 是什麼？</h4>
<ul>
<li><strong>HTML（超文件標記語言）</strong>：負責「網頁內容」與「結構」的描述，是網頁的骨架。</li>
<li><strong>CSS（層疊樣式表）</strong>：負責「網頁外觀、樣式、版面」的設計，是網頁的皮膚與裝飾。</li>
<li>兩者配合，讓你能打造美觀、結構良好的網站。</li>
</ul>
<h4>二、學習步驟建議</h4>
<ol>
<li>了解 HTML 與 CSS 各自用途與基本概念。</li>
<li>從基礎標籤（如 <code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;img&gt;</code>）與基本樣式（如顏色、字體、邊距）學起。</li>
<li>邊學邊練習：可用 <a href="https://codepen.io/" target="_blank">CodePen</a>、<a href="https://jsfiddle.net/" target="_blank">JSFiddle</a>、本地文字編輯器練習。</li>
<li>模仿簡單網頁，了解版型與排版原理。</li>
<li>逐步學習表格、表單、版面配置（如 Flexbox、Grid）。</li>
<li>挑戰自製個人履歷網頁、作品集、Landing Page 等小專案。</li>
</ol>
<h4>三、HTML 必學標籤與語法</h4>
<table>
<tbody>
<tr>
<th>標籤</th>
<th>用途</th>
<th>範例</th>
</tr>
<tr>
<td><code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code></td>
<td>標題（h1 最大）</td>
<td><code>&lt;h1&gt;主標題&lt;/h1&gt;</code></td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>段落文字</td>
<td><code>&lt;p&gt;這是一段文字。&lt;/p&gt;</code></td>
</tr>
<tr>
<td><code>&lt;a&gt;</code></td>
<td>超連結</td>
<td><code>&lt;a href="https://google.com"&gt;Google&lt;/a&gt;</code></td>
</tr>
<tr>
<td><code>&lt;img&gt;</code></td>
<td>插入圖片</td>
<td><code>&lt;img src="cat.jpg" alt="貓咪"&gt;</code></td>
</tr>
<tr>
<td><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code></td>
<td>無序/有序清單</td>
<td><code> &lt;ul&gt;<br/>   &lt;li&gt;項目1&lt;/li&gt;<br/>   &lt;li&gt;項目2&lt;/li&gt;<br/> &lt;/ul&gt; </code></td>
</tr>
<tr>
<td><code>&lt;div&gt;</code> / <code>&lt;span&gt;</code></td>
<td>區塊/行內分組、CSS 樣式輔助</td>
<td><code>&lt;div class="box"&gt;內容&lt;/div&gt;</code></td>
</tr>
<tr>
<td><code>&lt;table&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;td&gt;</code></td>
<td>表格</td>
<td><code> &lt;table&gt;<br/>   &lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;B&lt;/td&gt;&lt;/tr&gt;<br/> &lt;/table&gt; </code></td>
</tr>
<tr>
<td><code>&lt;form&gt;</code>、<code>&lt;input&gt;</code></td>
<td>表單與輸入欄位</td>
<td><code> &lt;form&gt;<br/>   &lt;input type="text" placeholder="姓名"&gt;<br/> &lt;/form&gt; </code></td>
</tr>
</tbody>
</table>
<h4>四、CSS 必學語法與範例</h4>
<ul>
<li>基本選擇器：<code>元素</code>、<code>.類別</code>、<code>#ID</code></li>
<li>常用屬性：<code>color</code>（文字顏色）、<code>background</code>（背景）、<code>font-size</code>、<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>border</code></li>
<li>文字對齊（<code>text-align</code>）、區塊對齊（<code>display</code>、<code>flex</code>、<code>grid</code>）</li>
<li>CSS 寫法可在 <code>&lt;style&gt;</code> 標籤、<code>style</code> 屬性或獨立 .css 檔案</li>
</ul>
<pre><code>
/* 樣式檔範例 */
h1 {
    color: #2d7f5e;
    font-size: 2em;
    text-align: center;
}
.box {
    background: #eaffea;
    padding: 1em;
    border-radius: 8px;
    margin-bottom: 1em;
}
#main {
    width: 80%;
    margin: auto;
}
        </code></pre>
<div class="tip"><strong>小技巧：</strong>
<ul>
<li>多善用瀏覽器「檢查元素」功能，調整 CSS 效果。</li>
<li>CSS 有「繼承」與「選擇器優先權」概念，遇到樣式衝突時要注意。</li>
</ul>
</div>
<h4>五、常見練習與專案</h4>
<ul>
<li>練習製作個人履歷網頁、名片網站、簡單 Landing Page。</li>
<li>模仿喜歡的網站版型，重新切版練習。</li>
<li>挑戰 CSS Flexbox、Grid 排版。</li>
<li>試著設計表單、導航列、圖文混排區塊。</li>
</ul>
<h4>六、常見錯誤與學習建議</h4>
<div class="warning"><strong>常見錯誤：</strong>
<ul>
<li>HTML 標籤忘記閉合、層級錯誤。</li>
<li>CSS 拼字錯誤、屬性寫錯或分號遺漏。</li>
<li>選擇器優先權搞混，導致樣式沒套用。</li>
<li>class 與 id 用法混淆。</li>
</ul>
</div>
<ul>
<li>多手寫、多練習，熟悉標籤與屬性。</li>
<li>常用 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML" target="_blank">MDN Web Docs</a> 查詢 HTML/CSS 語法。</li>
<li>參加線上挑戰如 <a href="https://www.frontendmentor.io/" target="_blank">Frontend Mentor</a>、<a href="https://cssbattle.dev/" target="_blank">CSS Battle</a>。</li>
</ul>
<h4>七、進階主題推薦</h4>
<ul>
<li>RWD 響應式網頁設計（media query）</li>
<li>CSS 動畫與過渡（animation, transition）</li>
<li>SCSS/SASS 等 CSS 預處理器</li>
<li>Bootstrap、Tailwind CSS 等框架</li>
<li>網頁無障礙（a11y）設計</li>
</ul>
<h2>Project</h2>
<p>請協助撰寫一個 Python Flask 網頁應用程式，前端表單需包含：<br/><br/>1. 一個「通關密碼」輸入欄位（用於驗證操作權限）<br/>2. 一個可填入使用者學號的欄位<br/>3. 一個用於設定新電子郵箱密碼的欄位<br/>4. 一個用於確認新電子郵箱密碼的欄位<br/><br/>使用者填寫上述欄位並提交表單後，系統應自動於 Google Workspace 平台建立對應的 email 帳號。</p>
<p><img caption="false" height="194" src="/images/create_g_workspace_email_account.png" width="200"/></p>
<hr/>
<p>專案提案書：自動化 Google Workspace 帳號建立 Flask 應用程式<br/><br/>一、專案背景與目標<br/><br/>隨著組織規模成長，IT 部門需經常協助新員工建立 Google Workspace（G Suite）電子郵箱帳號。為提升效率、降低人為疏失及強化資安控管，本專案擬開發一個簡易 Web 應用程式，允許經授權者透過表單操作，自動於 Google Workspace 建立新 email 帳號。<br/><br/>二、需求說明</p>
<p>1. 前端表單功能：<br/>   - 通關密碼欄位（授權驗證）<br/>   - 可填入學號數字的欄位<br/>   - 電子郵箱密碼欄位<br/>   - 確認電子郵箱密碼欄位<br/>   - 按下送出後，系統自動於 Google Workspace 建立對應帳號<br/><br/>2. 安全性設計： <br/>   - 必須驗證通關密碼<br/>   - 僅允許授權人員操作 (例如: 只允許在特定網段進行操作)<br/>   - 檢查 email 格式與密碼強度<br/>   - 禁止重複帳號建立<br/>   - 僅允許數字做為帳號前綴<br/><br/>三、技術規劃<br/><br/>1. 技術需求<br/><br/>- Python 3.x<br/>- Flask — 前後端 Web 框架<br/>- google-api-python-client — Google Workspace API 操作<br/>- google-auth — 驗證與授權<br/>- Jinja2 — 表單模板（隨 Flask 內建）<br/>- pip — Python 套件管理<br/><br/>2. 開發與部署環境<br/><br/>- 建議部署於安全的內部伺服器或 Docker 容器<br/>- 僅開放組織內部網路存取<br/><br/>四、安裝說明<br/><br/>1. Python 套件安裝<br/><br/>請於專案目錄下執行：</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">pip install Flask google-api-python-client google-auth</pre>
<p>如需管理虛擬環境，建議搭配 venv 或 conda 使用。<br/><br/>2. Google Workspace API 準備<br/><br/>1. 建立 Google Cloud Platform 專案並啟用 Admin SDK API<br/>2. 建立 Service Account，下載憑證檔（JSON）<br/>3. 設定 Domain-wide Delegation（網域代理授權）<br/>4. 於 Google Workspace 管理控制台授權 API 的 OAuth2 Scope：<br/>   - https://www.googleapis.com/auth/admin.directory.user<br/><br/>五、各階段程式碼設計<br/><br/>1. 表單頁面（Flask/Jinja2）<br/><br/>python name=templates/form.html</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!doctype html&gt;
&lt;title&gt;建立 Google Workspace 帳號&lt;/title&gt;
&lt;h2&gt;建立 Google Workspace 帳號&lt;/h2&gt;
&lt;form method="POST"&gt;
  &lt;label&gt;通關密碼：&lt;input type="password" name="secret" required&gt;&lt;/label&gt;&lt;br&gt;
  &lt;label&gt;學號：&lt;input type="text" name="prefix" required&gt;&lt;/label&gt;&lt;br&gt;
&lt;hr&gt;
以下密碼必須符合：&lt;br&gt;
至少 8 個字元&lt;br&gt;
建議包含：&lt;br&gt;
大寫 + 小寫字母&lt;br&gt;
數字&lt;br&gt;
特殊字元（如 !@#$)&lt;br&gt;
&lt;hr&gt;
  &lt;label&gt;新帳號密碼：&lt;input type="password" name="account_password" required&gt;&lt;/label&gt;&lt;br&gt;
  &lt;label&gt;確認密碼：&lt;input type="password" name="confirm_password" required&gt;&lt;/label&gt;&lt;br&gt;
  &lt;input type="submit" value="送出"&gt;
&lt;/form&gt;
{% with messages = get_flashed_messages() %}
  {% if messages %}
    &lt;ul&gt;
    {% for message in messages %}
      &lt;li&gt;{{ message }}&lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
  {% endif %}
{% endwith %}
</pre>
<p><br/>2. Flask 應用程式主體<br/><br/>python name=app.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, render_template, request, redirect, url_for, flash
from google.oauth2 import service_account
from googleapiclient.discovery import build
import os
 
app = Flask(__name__)
app.secret_key = os.urandom(24)
 
# 組態設定
DOMAIN = "your_domain_name"
ADMIN_EMAIL = "your_admin_email"
SERVICE_ACCOUNT_FILE = "C:/your_account_file_directory/service.json"
PASSWORD_SECRET = "your_password_secret"
SCOPES = ['https://www.googleapis.com/auth/admin.directory.user']
 
def create_user(email_prefix, password):
    credentials = service_account.Credentials.from_service_account_file(
        SERVICE_ACCOUNT_FILE, scopes=SCOPES)
    delegated_credentials = credentials.with_subject(ADMIN_EMAIL)
    service = build('admin', 'directory_v1', credentials=delegated_credentials)
    user_body = {
        "primaryEmail": f"{email_prefix}@{DOMAIN}",
        "name": {
            "givenName": email_prefix,
            "familyName": "User"
        },
        "password": password
    }
    user = service.users().insert(body=user_body).execute()
    return user
 
@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        secret = request.form['secret']
        prefix = request.form['prefix']
        account_password = request.form['account_password']
        confirm_password = request.form['confirm_password']

        # 權限驗證
        if secret != PASSWORD_SECRET:
            flash("通關密碼錯誤！")
            return redirect(url_for('index'))
        
        if not prefix.isdigit():
            flash("請輸入您的學號")
            return redirect(url_for('index'))
        
        # 密碼確認
        if account_password != confirm_password:
            flash("兩次密碼不一致，請重新確認！")
            return redirect(url_for('index'))
        
        # 密碼驗證（可加入更多規則）
        if len(account_password) &lt; 8:
            flash("密碼長度必須至少 8 個字元！")
            return redirect(url_for('index'))
        
        try:
            result = create_user(prefix, account_password)
            flash(f"帳號建立成功: {result['primaryEmail']}")
        except Exception as e:
            flash(f"建立帳號失敗: {str(e)}")
        return redirect(url_for('index'))
    return render_template('form.html')
 
if __name__ == '__main__':
    app.run(debug=True)
</pre>
<p><br/>3. 進階安全考量建議<br/><br/>- 密碼建議採用強度檢查（可用 Python 密碼強度套件輔助）<br/>- 增加帳號是否已存在的查核（可用 Google Workspace API 查詢帳號）<br/>- 日誌記錄所有操作，便於稽核<br/>- 部署於 HTTPS 環境<br/>- 建議將通關密碼與 API 金鑰資訊寫於環境變數或安全檔案，避免硬編碼<br/><br/>六、操作說明<br/><br/>1. 啟動服務<br/><br/>python app.py<br/><br/>預設於 http://localhost:5000 提供服務。<br/><br/>2. 使用流程<br/><br/>1. 開啟瀏覽器進入應用頁面<br/>2. 輸入通關密碼<br/>3. 輸入欲建立 email 的數字帳號前綴（如 123）<br/>4. 設定對應帳號密碼<br/>5. 按下送出，成功後將顯示建立結果<br/><br/>七、時程規劃（建議）<br/><br/></p>
<table border="1" cellpadding="6" cellspacing="0">
<thead>
<tr>
<th>階段</th>
<th>工作項目</th>
<th>預計工期</th>
</tr>
</thead>
<tbody>
<tr>
<td>需求確認</td>
<td>討論細節與權限</td>
<td>1 天</td>
</tr>
<tr>
<td>環境建置</td>
<td>API/Flask/金鑰設定</td>
<td>1 天</td>
</tr>
<tr>
<td>程式開發</td>
<td>表單與自動化功能撰寫</td>
<td>2 天</td>
</tr>
<tr>
<td>測試驗證</td>
<td>各種狀況測試與修正</td>
<td>1 天</td>
</tr>
<tr>
<td>上線部署</td>
<td>內部伺服器或容器部署</td>
<td>1 天</td>
</tr>
<tr>
<td>文件彙整</td>
<td>操作手冊與維運說明</td>
<td>1 天</td>
</tr>
</tbody>
</table>
<p><br/>八、結論<br/><br/>本專案將顯著提升 IT 人員建立 Google Workspace 帳號的效率與一致性，同時兼顧資訊安全。未來可依需求擴充驗證機制或加入更多自動化管理功能，如帳號停用、密碼重設等。<br/><br/></p>
<h3>Waitress</h3>
<p>採 <a href="https://pypi.org/project/waitress/">waitress</a> 執行 app.py</p>
<p>start_app.py 程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from waitress import serve
from app import app  # 這裡導入 app.py 中的 Flask 應用

# 這裡的 127.0.0.1:5000 是服務監聽的地址與端口
serve(app, listen='127.0.0.1:5000', threads=8)
</pre>
<p>利用 <a href="https://pypi.org/project/waitress/">waitress</a> 執行的 app.py 程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># pip install Flask google-api-python-client google-auth
from flask import Flask, render_template, request, redirect, url_for, flash
from google.oauth2 import service_account
from googleapiclient.discovery import build
import os

app = Flask(__name__)
app.secret_key = os.urandom(24)

# 組態設定
DOMAIN = "your_google_workspace_domain"
ADMIN_EMAIL = "yout_admin_email"
SERVICE_ACCOUNT_FILE = "C:/your_service_account_file_directory/service.json"
PASSWORD_SECRET = "your_passwod_secret"
SCOPES = ['https://www.googleapis.com/auth/admin.directory.user']

def create_user(email_prefix, password):
    credentials = service_account.Credentials.from_service_account_file(
        SERVICE_ACCOUNT_FILE, scopes=SCOPES)
    delegated_credentials = credentials.with_subject(ADMIN_EMAIL)
    service = build('admin', 'directory_v1', credentials=delegated_credentials)
    user_body = {
        "primaryEmail": f"{email_prefix}@{DOMAIN}",
        "name": {
            "givenName": email_prefix,
            "familyName": "User"
        },
        "password": password
    }
    user = service.users().insert(body=user_body).execute()
    return user

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        secret = request.form['secret']
        prefix = request.form['prefix']
        account_password = request.form['account_password']
        confirm_password = request.form['confirm_password']

        # 權限驗證
        if secret != PASSWORD_SECRET:
            flash("通關密碼錯誤！")
            return redirect(url_for('index'))
        
        if not prefix.isdigit():
            flash("請輸入您的學號")
            return redirect(url_for('index'))
        
        # 密碼確認
        if account_password != confirm_password:
            flash("兩次密碼不一致，請重新確認！")
            return redirect(url_for('index'))
        
        # 密碼驗證（可加入更多規則）
        if len(account_password) &lt; 8:
            flash("密碼長度必須至少 8 個字元！")
            return redirect(url_for('index'))
        
        try:
            result = create_user(prefix, account_password)
            flash(f"帳號建立成功: {result['primaryEmail']}")
        except Exception as e:
            flash(f"建立帳號失敗: {str(e)}")
        return redirect(url_for('index'))
    return render_template('form.html')

# 不使用 app.run()，讓 waitress 來處理
</pre>
<p>配合使用的 nginx.conf</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       [::]:80 ipv6only=on;
        server_name  your_first_server_domain your_server_cname_domain;

        #root   html;
        # 將 port 80 http 連結到倉儲的靜態網站
        root C:/your_static_site_directory/wcm2025_hw;
        index  index.html;

        location / {
            try_files $uri $uri/ =404;
        }
    }

    server {
        listen       [::]:443 ssl ipv6only=on;
        http2        on;
        server_name  your_first_server_domain your_server_cname_domain;

        ssl_certificate      fullchain.pem;
        ssl_certificate_key  privkey.pem;
        ssl_protocols        TLSv1.2 TLSv1.3;
        ssl_ciphers          HIGH:!aNULL:!MD5;

        location / {
            # https port 443 的連結資料是由近端 IPv6 or IPv4 port 8080 所提供
            #proxy_pass         http://[::1]:5000;
            proxy_pass         http://127.0.0.1:5000;
            proxy_set_header   Host $host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Proto $scheme;
        }
    }
}</pre>
<p>初步測試所使用的單一通關密碼進行驗證，可以再透過 flask-pyoidc 改為 <a href="https://learn.microsoft.com/zh-tw/entra/identity-platform/v2-protocols-oidc">OIDC</a> 認證通關:</p>
<p>先安裝必要模組:</p>
<p style="padding-left: 30px;">pip install Flask flask-pyoidc google-api-python-client google-auth</p>
<p>接著登入 Google Cloud Console 建立 OAuth 2.0 憑證:</p>
<ol>
<li>登入 Google Cloud Console</li>
<li>選擇你的專案，點選「建立憑證」&gt;「OAuth 用戶端 ID」</li>
<li>選擇「Web 應用程式」</li>
<li>設定授權的重新導向 URI（Redirect URI）</li>
<li>例如：http://localhost:5000/oidc/callback</li>
<li>取得「用戶端 ID」與「用戶端密鑰」</li>
</ol>
<p>接著建立 OIDC 設定檔:<br/><br/>將下列內容儲存為 oidc_secrets.json（請填入你自己的 client_id/client_secret）：</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">{
  "web": {
    "client_id": "YOUR_CLIENT_ID",
    "client_secret": "YOUR_CLIENT_SECRET",
    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
    "token_uri": "https://oauth2.googleapis.com/token",
    "issuer": "https://accounts.google.com",
    "redirect_uris": ["http://localhost:5000/oidc/callback"]
  }
}</pre>
<p>利用 OIDC 認證通關的 app.py:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># pip install Flask flask-pyoidc google-api-python-client google-auth
from flask import Flask, render_template, request, redirect, url_for, flash, session
from flask_pyoidc import OIDCAuthentication
from flask_pyoidc.provider_configuration import ProviderConfiguration, ClientMetadata
from google.oauth2 import service_account
from googleapiclient.discovery import build
import os
import json

app = Flask(__name__)
app.secret_key = os.urandom(24)

# === OIDC 設定 ===
with open('oidc_secrets.json') as f:
    oidc_conf = json.load(f)['web']

issuer = oidc_conf['issuer']
client_metadata = ClientMetadata(
    client_id=oidc_conf['client_id'],
    client_secret=oidc_conf['client_secret'],
    post_logout_redirect_uris=[oidc_conf['redirect_uris'][0]]
)
provider_config = ProviderConfiguration(
    issuer=issuer,
    client_metadata=client_metadata
)
auth = OIDCAuthentication({'default': provider_config}, app)

# === Google Workspace 設定 ===
DOMAIN = "your_google_workspace_domain"
ADMIN_EMAIL = "your_admin_email"
SERVICE_ACCOUNT_FILE = "C:/your_service_account_file_directory/service.json"
SCOPES = ['https://www.googleapis.com/auth/admin.directory.user']

def create_user(email_prefix, password):
    credentials = service_account.Credentials.from_service_account_file(
        SERVICE_ACCOUNT_FILE, scopes=SCOPES)
    delegated_credentials = credentials.with_subject(ADMIN_EMAIL)
    service = build('admin', 'directory_v1', credentials=delegated_credentials)
    user_body = {
        "primaryEmail": f"{email_prefix}@{DOMAIN}",
        "name": {
            "givenName": email_prefix,
            "familyName": "User"
        },
        "password": password
    }
    user = service.users().insert(body=user_body).execute()
    return user

@app.route('/logout')
def logout():
    # 清除 session 並 redirect 回首頁
    session.clear()
    return redirect(auth.client_end_session_uri('default', url_for('index', _external=True)))

@app.route('/', methods=['GET', 'POST'])
@auth.oidc_auth('default')
def index():
    # 取得登入者資訊
    user_session = auth.user_session
    user_email = user_session.userinfo['email']

    # 只允許特定網域
    if not user_email.endswith('@your_google_workspace_domain'):
        return "無權限，請使用組織帳號登入", 403

    if request.method == 'POST':
        prefix = request.form['prefix']
        account_password = request.form['account_password']
        confirm_password = request.form['confirm_password']

        if not prefix.isdigit():
            flash("請輸入您的學號")
            return redirect(url_for('index'))

        if account_password != confirm_password:
            flash("兩次密碼不一致，請重新確認！")
            return redirect(url_for('index'))

        if len(account_password) &lt; 8:
            flash("密碼長度必須至少 8 個字元！")
            return redirect(url_for('index'))

        try:
            result = create_user(prefix, account_password)
            flash(f"帳號建立成功: {result['primaryEmail']}")
        except Exception as e:
            flash(f"建立帳號失敗: {str(e)}")
        return redirect(url_for('index'))
    return render_template('form.html', user_email=user_email)</pre>
<p>配合 OIDC 認證的 form.html:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!doctype html&gt;
&lt;title&gt;建立 Google Workspace 帳號&lt;/title&gt;
&lt;h2&gt;建立 Google Workspace 帳號&lt;/h2&gt;
&lt;p&gt;目前登入：{{ user_email }}&lt;/p&gt;
&lt;form method="POST"&gt;
  &lt;label&gt;學號（Email @ 前）：&lt;input type="text" name="prefix" required pattern="\d+"&gt;&lt;/label&gt;&lt;br&gt;
  &lt;label&gt;新帳號密碼：&lt;input type="password" name="account_password" required&gt;&lt;/label&gt;&lt;br&gt;
  &lt;label&gt;再次輸入密碼：&lt;input type="password" name="confirm_password" required&gt;&lt;/label&gt;&lt;br&gt;
  &lt;input type="submit" value="送出"&gt;
&lt;/form&gt;
{% with messages = get_flashed_messages() %}
  {% if messages %}
    &lt;ul&gt;
    {% for message in messages %}
      &lt;li&gt;{{ message }}&lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
  {% endif %}
{% endwith %}
&lt;a href="{{ url_for('logout') }}"&gt;登出&lt;/a&gt;</pre>
<p>之後假設透過收集用戶的 email address 存為 allowed_email.txt， 採 OIDC 認證流程時，只允許電子郵箱在此檔案中的用戶有權限利用 app.py 建立 Google Workspace 帳號, 則 app.py 配合修改如下:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, render_template, request, redirect, url_for, flash, session
from flask_pyoidc import OIDCAuthentication
from flask_pyoidc.provider_configuration import ProviderConfiguration, ClientMetadata
from google.oauth2 import service_account
from googleapiclient.discovery import build
import os
import json

app = Flask(__name__)
app.secret_key = os.urandom(24)

# 讀取 allowed_email.txt，存成 set
def load_allowed_emails(filepath="allowed_email.txt"):
    with open(filepath, encoding="utf-8") as f:
        return set(line.strip().lower() for line in f if line.strip())

ALLOWED_EMAILS = load_allowed_emails()

# === OIDC 設定 ===
with open('oidc_secrets.json') as f:
    oidc_conf = json.load(f)['web']

issuer = oidc_conf['issuer']
client_metadata = ClientMetadata(
    client_id=oidc_conf['client_id'],
    client_secret=oidc_conf['client_secret'],
    post_logout_redirect_uris=[oidc_conf['redirect_uris'][0]]
)
provider_config = ProviderConfiguration(
    issuer=issuer,
    client_metadata=client_metadata
)
auth = OIDCAuthentication({'default': provider_config}, app)

# === Google Workspace 設定 ===
DOMAIN = "your_google_workspace_domain"
ADMIN_EMAIL = "your_admin_email"
SERVICE_ACCOUNT_FILE = "C:/your_service_account_file_directory/service.json"
SCOPES = ['https://www.googleapis.com/auth/admin.directory.user']

def create_user(email_prefix, password):
    credentials = service_account.Credentials.from_service_account_file(
        SERVICE_ACCOUNT_FILE, scopes=SCOPES)
    delegated_credentials = credentials.with_subject(ADMIN_EMAIL)
    service = build('admin', 'directory_v1', credentials=delegated_credentials)
    user_body = {
        "primaryEmail": f"{email_prefix}@{DOMAIN}",
        "name": {
            "givenName": email_prefix,
            "familyName": "User"
        },
        "password": password
    }
    user = service.users().insert(body=user_body).execute()
    return user

@app.route('/logout')
def logout():
    session.clear()
    return redirect(auth.client_end_session_uri('default', url_for('index', _external=True)))

@app.route('/', methods=['GET', 'POST'])
@auth.oidc_auth('default')
def index():
    user_session = auth.user_session
    user_email = user_session.userinfo['email'].lower()

    # 只允許在 allowed_email.txt 的 email
    if user_email not in ALLOWED_EMAILS:
        return render_template('not_allowed.html', user_email=user_email), 403

    if request.method == 'POST':
        prefix = request.form['prefix']
        account_password = request.form['account_password']
        confirm_password = request.form['confirm_password']

        if not prefix.isdigit():
            flash("請輸入您的學號")
            return redirect(url_for('index'))

        if account_password != confirm_password:
            flash("兩次密碼不一致，請重新確認！")
            return redirect(url_for('index'))

        if len(account_password) &lt; 8:
            flash("密碼長度必須至少 8 個字元！")
            return redirect(url_for('index'))

        try:
            result = create_user(prefix, account_password)
            flash(f"帳號建立成功: {result['primaryEmail']}")
        except Exception as e:
            flash(f"建立帳號失敗: {str(e)}")
        return redirect(url_for('index'))
    return render_template('form.html', user_email=user_email)</pre>
<p>templates/form.html</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!doctype html&gt;
&lt;title&gt;建立 Google Workspace 帳號&lt;/title&gt;
&lt;h2&gt;建立 Google Workspace 帳號&lt;/h2&gt;
&lt;p&gt;目前登入：{{ user_email }}&lt;/p&gt;
&lt;form method="POST"&gt;
  &lt;label&gt;學號（Email @ 前）：&lt;input type="text" name="prefix" required pattern="\d+"&gt;&lt;/label&gt;&lt;br&gt;
  &lt;label&gt;新帳號密碼：&lt;input type="password" name="account_password" required&gt;&lt;/label&gt;&lt;br&gt;
  &lt;label&gt;再次輸入密碼：&lt;input type="password" name="confirm_password" required&gt;&lt;/label&gt;&lt;br&gt;
  &lt;input type="submit" value="送出"&gt;
&lt;/form&gt;
{% with messages = get_flashed_messages() %}
  {% if messages %}
    &lt;ul&gt;
    {% for message in messages %}
      &lt;li&gt;{{ message }}&lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
  {% endif %}
{% endwith %}
&lt;a href="{{ url_for('logout') }}"&gt;登出&lt;/a&gt;</pre>
<p>另外新增一個 templates/not_allowed.html</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!doctype html&gt;
&lt;title&gt;未授權訪問&lt;/title&gt;
&lt;h2&gt;未授權訪問&lt;/h2&gt;
&lt;p&gt;您的 email（{{ user_email }}）不在允許名單中，無法建立帳號。&lt;/p&gt;
&lt;a href="{{ url_for('logout') }}"&gt;登出&lt;/a&gt;</pre>
<p></p>
<h3>API</h3>
<p>以下是「建立 Google Cloud Platform 專案並啟用 Admin SDK API」的詳細操作步驟，適用於管理 Google Workspace 的自動化應用：<br/><br/>一、建立 Google Cloud Platform (GCP) 專案<br/><br/>1. 登入 Google Cloud Console<br/>   前往 [Google Cloud Console](<a href="https://console.cloud.google.com">https://console.cloud.google.com</a>)。<br/><br/>2. 建立新專案<br/>   - 點選左上角的「專案選單」下拉按鈕（通常會顯示你目前的專案名稱）。<br/>   - 在彈出的專案視窗中，點選「新建專案」。<br/>   - 輸入專案名稱（如：workspace-account-automation）。<br/>   - 選擇對應的組織與資料夾（如有需要）。<br/>   - 點選「建立」。<br/><br/>3. 切換到新專案<br/>   - 專案建立完成後，點選右上角的「通知」可快速切換到新專案，或再次於專案選單中切換至新專案。<br/><br/>二、啟用 Admin SDK API and Gmail API<br/><br/>1. 進入 API 管理頁面<br/>   - 確認你當前專案已切換至剛建立的專案。<br/>   - 在左側導覽列，選擇「API 與服務」→「程式庫」。<br/><br/>2. 搜尋並啟用 Admin SDK<br/>   - 在搜尋框輸入 `Admin SDK`。<br/>   - 點選搜尋結果中的「Admin SDK」。<br/>   - 點選「啟用」。</p>
<ul>
<li data-end="633" data-start="554">
<p data-end="633" data-start="556">前往 Google Cloud Console：<br data-end="583" data-start="580"/><a class="cursor-pointer" data-end="633" data-start="588" rel="noopener" target="_new">https://console.cloud.google.com/apis/library</a></p>
</li>
<li data-end="710" data-start="634">
<p data-end="651" data-start="636">搜尋並啟用對應 API，例如：</p>
<ul data-end="710" data-start="654">
<li data-end="672" data-start="654">
<p data-end="672" data-start="656">Google Drive API</p>
</li>
<li data-end="686" data-start="675">
<p data-end="686" data-start="677">Gmail API</p>
</li>
<li data-end="710" data-start="689">
<p data-end="710" data-start="691">Google Sheets API 等</p>
</li>
</ul>
</li>
</ul>
<p>三、（進階）建立並下載 Service Account 金鑰</p>
<p><a href="https://console.cloud.google.com/iam-admin/serviceaccounts">https://console.cloud.google.com/iam-admin/serviceaccounts</a> </p>
<p>建立新的服務帳戶並啟用 Domain-wide Delegation</p>
<p>步驟：</p>
<p>建立一個新的 Service Account（在建立流程中會有「進階設定」）</p>
<p>詳細步驟如下：</p>
<p>1. 前往 [Google Cloud Console – Service Accounts](https://console.cloud.google.com/iam-admin/serviceaccounts)<br/>2. 點選【建立服務帳戶】<br/>3. 輸入服務帳戶名稱、ID、描述，點【建立並繼續】<br/>4. 權限頁面可以直接點【繼續】<br/>5. 第三步是「授予使用者訪問權限」：忽略它 ➝ 點【完成】<br/>6. 建立完成後，回到該服務帳戶的詳細資料頁面</p>
<p>啟用 Domain-wide Delegation：</p>
<p>1. 點你剛建立的服務帳戶名稱<br/>2. 點選頁面上方的【Domain-wide Delegation】分頁<br/>3. 按下【啟用網域範圍代理】按鈕<br/>4. 填寫「產品名稱」（任意填即可，如：Workspace Bot）<br/>5. 點【儲存】</p>
<p>完成後你會看到：</p>
<p>* 一個 Client ID`（要貼去 Workspace 管理控制台使用）<br/>* 「View Google Workspace Admin Console」按鈕</p>
<p>接著在 Workspace Admin Console 授權這個 Client ID</p>
<p>1. 登入 [admin.google.com](https://admin.google.com)（必須是超級管理員）<br/>2. 前往：安全性 (Security) &gt; Access and data control &gt; API 控制權限 (API controls)&gt; 網域範圍代理（Domain-wide delegation) &gt; MANAGE DOMAIN WIDE DELEGATION<br/>3. 點【新增】<br/>4. 輸入你剛剛的 Client ID<br/>5. 輸入你要授權的 OAuth scopes，例如：</p>
<p>https://www.googleapis.com/auth/admin.directory.user<br/>https://www.googleapis.com/auth/admin.directory.group</p>
<h1>Brython</h1>
<p><a href="https://brython.info/">Brython</a> 是一個將 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 語法編譯為 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">JavaScript</a> 的工具，能直接在瀏覽器中以 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 撰寫前端網頁程式。</p>
<p><button id="add1to100">1 add to 100</button><button id="robot1">機器人巡邏</button><button id="free_walk">自由行</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 累加程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
<!-- 累加程式結束 --> <!-- 機器人巡邏程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

robot1_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py"

# 從 gist 取得程式碼
robot1_src = open(robot1_url).read()
def robot1(ev):
    Ace2.editor.setValue(robot1_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "robot1" 的按鈕點按時, 執行 robot1 方法
doc["robot1"].bind('click', robot1)
</script>
<!-- 機器人巡邏程式結束 --></p>
<!-- 機器人自由行程式開始 -->
<p>
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

free_walk_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9d55811467e411eb89f74171d8a586ae9f1a96aa/brython_robot_free_walk.py"

# 從 gist 取得程式碼
free_walk_src = open(free_walk_url).read()
def free_walk(ev):
    Ace2.editor.setValue(free_walk_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "free_walk" 的按鈕點按時, 執行 robot1 方法
doc["free_walk"].bind('click', free_walk)
</script>
</p>
<!-- 機器人自由行程式結束 -->
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p></p>
<h2>Brython_ex</h2>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/b4134dc3724f9c6aa1de7534a74f298288de0fa5/round_dot_move.py">基本動態模擬</a></p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/b4134dc3724f9c6aa1de7534a74f298288de0fa5/round_dot_move.py">機器人繞圈</a></p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9d55811467e411eb89f74171d8a586ae9f1a96aa/brython_robot_free_walk.py">機器人自由行</a></p>
<p><a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/adc0e2c8fbab839f9c0132547a4ee4bffcfe370f/brython_robot.py">brython_robot.py</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/27541a79c916e42c1f32509aa3a1c6e086923d47/module_patrol.py">導入模組繞圈</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/a1de47ae2a2c941d6abe945bd58ae79ba38be8c6/brython1_ijkm_control.py">ijkm 控制</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/f433e7b2ebe5bdb6b719e3343b27d25f4cc7de77/oop_turn_right.py">OOP 機器人右轉</a></p>
<p><a href="https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/97673a5dad110b8c443ffc41a1c1b69e0f2cde1a/brython_robot_extended.py">brython_robot_extended.py</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/27541a79c916e42c1f32509aa3a1c6e086923d47/brython_robot_extended_ex1.py">多機器人模擬</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/27541a79c916e42c1f32509aa3a1c6e086923d47/3robot_go_through_10by10.py">10x10 three robots</a></p>
<p style="padding-left: 60px;">請修改上列程式，可以讓三個 robot 快速通過 20x20 的模擬世界中的每一格。</p>
<p><a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/e3e7ac9102190dd3fe708f6f63513faf9c30c970/brython_robot2.py">brython_robot2.py</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/0617b603740786be45b9642b0bd0f8d7805985c9/brython_robot2_ex1.py">加入採收作物</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/e3e7ac9102190dd3fe708f6f63513faf9c30c970/brython_robot2_ex2.py">可執行採收</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/538c4d06a96244181961a02c57f993cfd747e34b/brython_robot2_ex3.py">指定位置採收</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/14e9d8902c181902ca3c48c942393fab3466cdeb/brython_robot2_ex4.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/85aeba229c565068c917e157963baaa2acb98f40/harvest10.json">按鍵採收</a> (按下 i 鍵左轉，按下 j 鍵向前走一步，按下 p 鍵可以採收，每次最多採收 5 個農作物)</p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/d9d029eb456b498b076676b234621b5ed8f86d7a/brython_robot2_ex5.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/85aeba229c565068c917e157963baaa2acb98f40/harvest10.json">頁面 button 採收</a> (含載入 json 格式附加作物配置檔案)</p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/f757732fff559396c695b790042e3c77b0e67347/brython_robot2_ex6.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/85aeba229c565068c917e157963baaa2acb98f40/harvest10.json">手動裝盒採收</a> (每 5 個紅蘿蔔裝一盒，裝盒前個數標示在右上方，採收盒數標示在左上方)</p>
<p><a href="https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/d45c53ce1d922075c8847dae2c77cb18245e14f2/brython_robot3.py">brython_robot3.py</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/06cafae3030b44d156896a15e253d757d9fa371c/brython_robot3_ex1.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/85aeba229c565068c917e157963baaa2acb98f40/harvest10.json">手動裝盒採收</a> (含判斷內建場景或由 world URL 變數載入 json 檔案場景)</p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/044cf97b64844da11d1f33277c7b2e2d3159b656/brython_robot3_ex2.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/85aeba229c565068c917e157963baaa2acb98f40/harvest10.json">自動巡迴裝盒採收</a> (滿載後回到原點)</p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/3ee062e229f14ec991711f07cb2ceaaedb0c2a09/brython_robot3_ex3.py">自動巡迴裝盒採收</a> (滿載後停止)</p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/d45c53ce1d922075c8847dae2c77cb18245e14f2/brython_robot3_ex4.py">碰牆之前直走並採收</a> (while, front_is_clear, move, object_here, pick_carrot 等函式應用)</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 使用一個非同步迴圈，等待每個動作完成
def check_and_move():
    if robot.front_is_clear():
        robot.move(1)
        if robot.object_here():
            robot.pick_carrot()
        # 延遲執行，給予機器人時間移動
        timer.set_timeout(check_and_move, 500)

# 延遲啟動迴圈，確保前面的動作有足夠時間被排入佇列
timer.set_timeout(check_and_move, 1000)</pre>
<p style="padding-left: 60px;">為何需要「非同步迴圈」？<br/><br/>簡單來說，你需要一個非同步迴圈來讓程式「等待」機器人完成動作，而不是一口氣全部執行完。<br/><br/>這段程式碼的邏輯之所以需要這樣設計，是因為 Brython 機器人程式庫中的方法（如 robot.move()、robot.turn_left() 和 robot.pick_carrot()）都是非同步的。<br/><br/>讓我們分解一下這背後的原因：<br/><br/>1. 動作是有延遲的 (Actions Have Delay)<br/><br/>機器人程式庫為了模擬真實的動作過程，例如移動、轉彎，會設定一個時間延遲（例如 200 或 300 毫秒）。當你呼叫 robot.move(1) 時，這個指令並不會立即完成，而是會被加入一個「待辦事項」佇列 (queue) 中，然後由一個定時器 (timer) 在稍後執行。<br/><br/>2. while 迴圈是同步的 (A while Loop is Synchronous)<br/><br/>與機器人的非同步動作不同，Python 的 while 迴圈是同步且立即執行的。當你寫下：<br/>Python<br/><br/>while robot.front_is_clear():<br/>    robot.move(1)<br/><br/>程式碼會：<br/><br/>    立即檢查 robot.front_is_clear()。<br/><br/>    如果為 True，立即呼叫 robot.move(1)。這個呼叫只會把「移動」指令放到佇列中，不會等待它完成。<br/><br/>    然後，程式會立即回到第一步，再次檢查 robot.front_is_clear()。<br/><br/>因為機器人還沒來得及移動（它的狀態沒有改變），所以 robot.front_is_clear() 會在原地連續被檢查數百甚至數千次，直到程式結束或卡死。這會導致以下問題：<br/><br/>    無限迴圈： 如果前方始終暢通，程式會陷入無限迴圈，因為機器人的位置從未改變，無法觸發迴圈終止條件。<br/><br/>    不正確的行為： 機器人可能會忽略它前方的牆壁或物件，因為它在原地就已經把所有指令都發送出去了。<br/><br/>3. 非同步迴圈如何解決問題？<br/><br/>你所提供的 check_and_move() 函式就是一個解決方案。它的運作方式是：<br/><br/>    檢查條件： if robot.front_is_clear():<br/><br/>    執行動作： 如果條件為真，執行 robot.move(1)。<br/><br/>    設定延遲： 呼叫 timer.set_timeout(check_and_move, 500)。這個指令告訴瀏覽器：「請在 500 毫秒後，再次呼叫 check_and_move() 這個函式。」<br/><br/>這樣做的好處是，程式執行完 check_and_move() 函式後就結束了，不會陷入迴圈。它將控制權交還給瀏覽器，讓定時器在未來重新觸發。在這 500 毫秒的延遲期間，機器人有足夠的時間完成它在佇列中的移動動作，並更新它在世界中的位置。當 check_and_move() 再次被呼叫時，機器人的狀態已經是最新的了。<br/><br/>結論是，這種非同步設計是為了讓同步的程式邏輯能夠與非同步的視覺化動作完美地協同工作，避免程式陷入僵局或產生錯誤的行為。</p>
<p><a href="https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4.py">brython_robot4.py</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a></p>
<p style="padding-left: 30px;">這套程式庫的設計目標是提供一個可視化的機器人模擬環境，讓使用者可以用類似 Reeborg 的「同步」方式來控制機器人，但底層實際上是基於瀏覽器的非同步機制 browser.aio 實現的。<br/><br/>程式庫主要由以下幾個類別和函式組成：<br/><br/>1. World 類別<br/><br/>這是整個模擬環境的核心。它負責世界的繪圖和狀態管理，但本身不處理機器人的動作。<br/><br/>    __init__(self, width, height, ...): 初始化一個指定寬度和高度的世界，並建立多個 html.CANVAS 圖層。每個圖層負責繪製不同的元素（例如：網格、背景、牆壁、物件、機器人）。<br/><br/>    _create_layers(): 建立並返回一個字典，包含各種不同用途的 CANVAS 圖層。<br/><br/>    _init_html(): 將這些圖層以絕對定位的方式堆疊到一個主容器中，並將其插入到網頁的指定 div 元素（brython_div1）裡。<br/><br/>    繪圖方法 (_draw_grid, _draw_walls, _draw_background, draw_objects): 這些方法負責在對應的 CANVAS 圖層上繪製靜態或動態的場景元素。<br/><br/>2. AnimatedRobot 類別<br/><br/>這是最底層的機器人動畫引擎。它直接處理機器人的位置和朝向變化，並負責將動畫「畫」出來。<br/><br/>    __init__(self, world, x, y, ...): 初始化機器人，設定其在世界中的位置 (x, y)、朝向 (facing)，並獲得用於繪製的 CANVAS 繪圖上下文 (ctx)。<br/><br/>    async move(self, steps=1): 這是關鍵的 async 方法。它會一個一個步驟地移動機器人。<br/><br/>        在每次移動前，它會檢查前方是否有牆壁阻擋。如果有，會印出錯誤訊息並停止。<br/><br/>        沒有阻擋時，它會更新機器人的位置，並呼叫 _draw_trace 和 _draw_robot 進行繪圖。<br/><br/>        最重要的是，它使用 await aio.sleep(0.2) 來暫停程式的執行，等待 200 毫秒。這就是讓動作看起來像動畫的原因。程式會在此處「掛起」，直到動畫時間過去，然後才會繼續執行。<br/><br/>    async turn_left(self): 類似 move，這是一個 async 方法。它會更新機器人的朝向，重新繪製機器人圖片，然後 await aio.sleep(0.3) 來等待轉向動畫完成。<br/><br/>3. SmartRobot 類別<br/><br/>這個類別是使用者與機器人互動的主要介面。它將 AnimatedRobot 的基本動作進行包裝，並提供更進階、更人性化的功能，如 turn_right、move_backward 和 pick_carrot。<br/><br/>    __init__(self, base_robot): 接受一個 AnimatedRobot 實例，作為其動作的執行基礎。它還會追蹤機器人收集到的胡蘿蔔數量。<br/><br/>    async move(self, steps=1): 這個方法會呼叫 await self.base.move(steps)。使用者在這裡呼叫 robot.move(2) 時，程式會在這裡等待，直到底層 AnimatedRobot 的兩個單步移動都完成，才會繼續執行下一行程式碼。<br/><br/>    pick_carrot(): 這是一個同步方法，因為採集胡蘿蔔的動作不需要動畫延遲。它會檢查當前位置是否有胡蘿蔔，並更新內部狀態和世界繪圖。<br/><br/>    wall_in_front() 和 front_is_clear(): 這些是同步的狀態檢查方法。它們直接返回當前位置是否有牆壁的布林值，不需要等待，因為它們不涉及動畫。<br/><br/>4. 輔助函式<br/><br/>    async load_scene_from_url(url): 這個函式將原本的回調函式 ajax 請求，包裝成一個 async 函式。它使用 aio.Future() 來等待 ajax 請求完成，然後返回場景數據。這使得應用程式可以像同步呼叫一樣寫 await load_scene_from_url(...)。<br/><br/>    create_buttons(robot) 和 on_key(robot, evt): 這兩個函式負責建立網頁上的按鈕和鍵盤事件監聽。當使用者點擊按鈕或按鍵時，它會呼叫 aio.run() 來啟動一個新的協程，執行對應的機器人動作。<br/><br/>呼叫應用程式 (main.py) 的內容<br/><br/>應用程式的程式碼非常簡潔，完美展示了如何利用程式庫的非同步特性，寫出像同步一樣直觀的程式碼。<br/><br/>1. 程式結構<br/><br/>    應用程式的主體包含兩個 async 函式：robot_actions 和 main。<br/><br/>    整個程式的執行從 aio.run(main()) 開始。<br/><br/>2. async def main()<br/><br/>這是程式的入口點。<br/><br/>    它首先檢查網址參數，以決定是從遠端載入場景還是使用預設場景。<br/><br/>    關鍵在於 await load_scene_from_url(world_url)。這行程式碼會暫停 main() 函式的執行，直到遠端場景數據完全下載並解析完成。<br/><br/>    接著，它使用載入的場景數據呼叫 init() 來初始化世界和機器人。<br/><br/>    最後，它呼叫 await robot_actions(robot)，將控制權交給機器人的行為邏輯。<br/><br/>3. async def robot_actions(robot)<br/><br/>這就是使用者撰寫的機器人行為腳本。<br/><br/>    它使用 await 關鍵字來呼叫 robot 物件的 async 方法，例如 await robot.move(2) 和 await robot.turn_left()。<br/><br/>    程式會逐行執行，並在每個 await 點暫停，直到對應的動畫完成。這正是 Reeborg 帶給使用者的「同步」感覺。<br/><br/>    while robot.front_is_clear() 迴圈也完美地體現了這一點。程式碼會先判斷前方是否暢通，如果暢通，就執行 await robot.move(1)，然後再次回到迴圈開頭進行檢查。這個過程是自動化的，使用者不需要關心延遲或回調。<br/><br/>總結來說，這套程式庫與應用程式的設計模式，成功地將複雜的瀏覽器非同步操作封裝起來，透過 Brython 的 browser.aio 協程框架，為使用者提供了一個直觀、易於理解且類似同步的編程環境，非常適合程式教育。</p>
<p>brython_robot3.py 程式庫的核心是手動的佇列和回調函式。<br/><br/>    執行流程：當呼叫 robot.move() 時，程式會把這個動作加到一個內部佇列 (self.queue) 裡。一個獨立的執行器會從佇列中取出動作，然後使用 timer.set_timeout() 來安排動畫。<br/><br/>    同步錯覺：使用者在 robot_actions 函式中，必須手動使用 timer.set_timeout() 來安排下一個動作的執行，並給予足夠的延遲時間（例如 timer.set_timeout(check_and_move, 1000)）。這種方法非常脆弱，如果延遲時間設定不當，機器人動作就會出錯。<br/><br/>    優點：不依賴任何特定的非同步框架。<br/><br/>    缺點：<br/><br/>        難以維護：程式碼會變得非常複雜，容易陷入俗稱的「回調地獄」。<br/><br/>        不夠靈活：無法在一個動作完成後立即執行條件判斷（例如 if robot.object_here()），因為判斷程式碼必須被包裝在回調函式裡，並等待非同步動作完成。<br/><br/>        不夠直觀：使用者必須理解 timer.set_timeout() 的非同步行為，這與 Reeborg 的同步直觀感相去甚遠。<br/><br/><br/>brython_robot4.py 程式庫的核心是 Brython 的 browser.aio 協程框架。<br/><br/>    執行流程：當呼叫 await robot.move() 時，Brython 會暫停這個協程的執行，並將控制權交還給瀏覽器的事件迴圈。底層的 AnimatedRobot.move() 方法會執行動畫，並在動畫完成後，使用 await aio.sleep() 重新啟動協程。<br/><br/>    同步錯覺：await 關鍵字讓程式碼看起來像是同步執行。當程式碼遇到 await 時，它會等待非同步操作完成，然後再繼續執行下一行程式碼。這讓使用者可以直觀地將動作串聯在一起，例如 await robot.move(); await robot.turn_left();。<br/><br/>    優點：<br/><br/>        高度直觀：使用者程式碼簡單且易於閱讀，完全符合 Reeborg 帶來的「同步」體驗。<br/><br/>        強大穩定：由 browser.aio 框架管理執行順序，避免了手動設定延遲時間的錯誤，確保了動作的正確性和順序性。<br/><br/>        更接近原生 Python：async/await 是 Python 3.5+ 的標準語法，讓使用者學到的技能更具通用性。<br/><br/>總結</p>
<p>特性              brython_robot3.py                              brython_robot4.py)</p>
<p>核心技術        手動實現的佇列和回調函式                       browser.aio 協程框架</p>
<p>使用者程式     必須使用 timer.set_timeout 來安排動作    使用 await 關鍵字，程式碼看起來是同步的</p>
<p>穩定性           易因手動延遲時間設定不當而發生錯誤         穩定可靠，由框架保證執行順序</p>
<p>程式碼複雜度  較高，容易產生回調地獄                           較低，程式碼線性直觀<br/><br/>結論: brython_robot3.py 是土法煉鋼，而 brython_robot4.py 則是採用了現代化的、更強大和更優雅的程式設計模式。新版讓使用者可以專注於機器人的邏輯，而不需要擔心底層的非同步細節。</p>
<hr/>
<p>Optimization:</p>
<p style="padding-left: 30px;">一位製造商想設計一個開口式的盒子，其底部為長方形，寬為 x、長為 y，且總表面積為 80 平方公分。 請問要使盒子的體積達到最大，應該選用哪些尺寸？</p>
<p style="padding-left: 30px;">直接利用 Python 以 <a href="https://en.wikipedia.org/wiki/Differential_evolution">Differential Evoluation</a> 運算: <a href="/downloads/de_volume_max.py">de_volume_max.py</a></p>
<p style="padding-left: 60px;">參考: </p>
<p style="padding-left: 90px;"><a href="/downloads/de_volume_max.c">de_volume_max.c</a></p>
<p style="padding-left: 30px;">也可以採網頁前端使用 Brython，後端採 Python 執行運算後將資料傳回網頁: <a href="/downloads/brython_w_flask.7z">brython_w_flask.7z</a></p>
<h2>Robot_ex</h2>
<p>在 Brython 環境事先導入 <a href="https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot.py">brython_robot.py</a> 後, 可以利用下列範例學習 Python 程式語法:</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex1.py">基本變數與數值操作</a> (1)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex2.py">字串與輸出</a> (2)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex3.py">基本邏輯與條件判斷</a> (3)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex4.py">函式定義與呼叫</a> (4)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex5.py">函式參數與重複使用</a> (5)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex6.py">for 迴圈基礎</a> (6)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex7.py">while 迴圈</a> (7)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex8.py">List 基礎</a> (8)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex9.py">Dict 應用</a> (9)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex10.py">邏輯運算子(and, or, not)</a> (10)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex11.py">錯誤處理(try / except)</a> (11)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex12.py">多維清單(List of List)</a> (12)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex13.py">自訂類別與物件屬性</a> (13)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex14.py">類別繼承與方法覆寫</a> (14)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex15.py">Tuple 與不可變資料</a> (15)</p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex16.py">條件運算式(ternary if)</a> (16)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex17.py">匿名函式(lambda)</a> (17)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex18.py">enumerate() 搭配清單</a> (18)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex19.py">yield 與 Generator 動作序列控制</a> (19)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex20.py">函式參數：*args</a> (20)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex21.py">列表推導式(計算指令長度)</a> (21)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex22.py">使用 zip() 交錯步數與轉向</a> (22)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex23.py">使用 map() 與 lambda</a> (23)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex24.py">類別屬性(Class variable)</a> (24)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex25.py">屬性封裝與方法鏈</a> (25)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex26.py">多層巢狀資料結構應用</a> (26)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex27.py">函式回傳函式(Closure)</a> (27)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex28.py">集合(Set)與推導式</a> (28)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex29.py">字典推導式(Dict Comprehension)</a> (29)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex30.py">自訂例外</a> (30)</span></p>
<p><span class="pl-c"><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex31.py">類別方法與靜態方法</a> (31)</span></p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex32.py">使用 enumerate() 實用技巧</a> (32)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex33.py">生成器 yield 動作序列控制</a> (33)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex34.py">用 filter() 篩選動作</a> (34)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex35.py"><span class="pl-c">利用 sorted() 排序步驟</span></a> (35)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex36.py">初探裝飾器(Decorator)</a> (36)</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/7f33223c0c669eac2a2bbce5c60b610edfdd9c72/brython_robot_ex37.py">使用 next() 和迭代器控制流程</a> (37)</p>
<h1>Ref</h1>
<h2>Reeborg</h2>
<p><a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1.py</a></p>
<p><a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_east_west.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_east_west.py</a> </p>
<hr/>
<p><a href="https://mde.tw/reeborg">https://mde.tw/reeborg</a></p>
<p><a href="https://github.com/mdecycu/cs101">https://github.com/mdecycu/cs101</a></p>
<p><a href="https://reeborg.ca/docs/en/python/index.html">https://reeborg.ca/docs/en/python/index.html</a></p>
<p><a href="https://aroberge.github.io/reeborg-api/">https://aroberge.github.io/reeborg-api/</a></p>
<p>if using local static port 9442:</p>
<p style="padding-left: 30px;"><a href="https://127.0.0.1:8442/reeborg/?lang=en&amp;mode=python&amp;menu=%2Freeborg%2Fworlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=%2Freeborg%2Fworlds%2Ftutorial_en%2Fharvest1.json&amp;editor=%2Freeborg%2Fpython%2Fharvest1.py">Reeborg</a></p>
<p>For Github Pages:</p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=%2Freeborg%2Fworlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=%2Freeborg%2Fworlds%2Ftutorial_en%2Fharvest1.json&amp;editor=%2Freeborg%2Fpython%2Fharvest1.py">Reeborg</a></p>
<p></p>
<h3>ex1</h3>
<p><a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1.py</a> 是已知的機器人採收紅蘿蔔的程式，經由以下與 Copilot 的對話，希望透過 Python Class 的編寫解決特定範圍農作物採收的程式。</p>
<p>問句:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">以下是 Reeborg 一個用來採收紅蘿蔔的程式, 目前位於 (3,3) 到 (8,8) 的區域中各座標點, 各有一個紅羅蔔等待採收, 現在想要建立一個 harvest() class, 可以利用 (3,3), (8,8)作為標定有農作物必須採收的兩個區域對角點座標, 而程式可以利用此一 harvest 類別生成案例完成採收的任務: def turn(int):
    for i in range(int):
        turn_left()
        
def new_move(int):
    for i in range(int):
        move()
        
def harvest_one_row():
    while object_here():
        take()
    else:
        move()
# move to the field
new_move(2)
turn_left()
new_move(2)

for i in range(3):
    while is_facing_north():
        for i in range(6):
            harvest_one_row()
        for i in range(2):
            turn(3)
            move() 
    else:
        for i in range(6):
            harvest_one_row()
        for i in range(2):
            turn_left()
            move()</pre>
<p>AI 回答: <a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_class_ex1.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_class_ex1.py</a> </p>
<p>進一步要求:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">請在類別中加上一個採收方向的參數, 內建變數是 horizontal 採收, 也就是由西邊往東邊的水平方向進行採收, 但若該方向變數設為 vertical 則會由南邊往北的所謂垂直方向進行採收</pre>
<p>AI 回應: <a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_class_ex2.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_class_ex2.py </a> </p>
<p>延伸到採收 harvest2 農田: <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest2.json&amp;editor=python/harvest1_class_ex1.py">https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest2.json&amp;editor=python/harvest1_class_ex1.py</a> </p>
<p>但卻沒能套用到 harvest3 農田: <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest3.json&amp;editor=python/harvest1_class_ex1.py">https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest3.json&amp;editor=python/harvest1_class_ex1.py</a> </p>
<p>而必須要在每一個座標點留下或放入一個紅蘿蔔: <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest3.json&amp;editor=python/harvest1_class_ex3.py">https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest3.json&amp;editor=python/harvest1_class_ex3.py </a> </p>
<h3>Otto_ninja</h3>
<p><a href="https://www.printables.com/model/231580-otto-ninja-starter-robot/files">https://www.printables.com/model/231580-otto-ninja-starter-robot/files</a> </p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/NDIwhuxQPN8?si=ED_FAObUkAVFT5L-" title="YouTube video player" width="560"></iframe></p>
<h2>tkinter</h2>
<p><a href="/downloads/tkinter_robot.7z">tkinter_robot.7z</a></p>
<h2>Pyodide</h2>
<p><a href="https://pyodide.org">Pyodide</a> 是一個將 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 解譯器和常用科學套件 (例如: <a href="https://numpy.org/">numpy</a>、<a href="https://scipy.org/">scipy</a>、<a href="https://matplotlib.org/">matplotlib</a> 等) 編譯成 <a href="https://webassembly.org/">WebAssembly</a>，可在瀏覽器中執行 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 程式的專案。</p>
<p><a href="https://pyodide.org">Pyodide</a> 是將 <a href="https://github.com/python/cpython">CPython</a> 編譯為 <a href="https://webassembly.org/">WebAssembly</a>，可在瀏覽器或其他 <a href="https://webassembly.org/">WebAssembly</a> 環境中執行；而 <a href="https://github.com/python/cpython">CPython</a> 是標準的原生 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 解譯器，運行在作業系統上。換言之，<a href="https://pyodide.org">Pyodide</a> 是為在瀏覽器中執行 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 而設計的 <a href="https://github.com/python/cpython">CPython</a> 移植版本。<a href="https://pyodide.org">Pyodide</a> 可與 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">JavaScript</a> 雙向互動，讓 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 程式能呼叫 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">JavaScript</a> 函數並操作網頁元素，也能被 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">JavaScript</a> 呼叫執行 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 程式碼。</p>
<p>
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
</p>
<p><button id="version">version</button> <button id="hello_button">hello</button> <button id="add1to100">1 add to 100</button> <button id="robot1">機器人巡邏</button><button id="free_walk">自由行</button> <button id="numpy_ode">numpy_ode</button></p>
<!-- Ace Editor Scripts -->
<p>
<script src="/static/ace/FileSaver.min.js"></script>
<script src="/static/ace/filereader.js"></script>
<script src="/static/ace/ace.js"></script>
<script src="/static/ace/ext-language_tools.js"></script>
<script src="/static/ace/mode-python.js"></script>
<script src="/static/ace/snippets/python.js"></script>
</p>
<!-- Editor 1 -->
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run1">Run</button> <button id="kw_output1">Output</button> <button id="kw_clear_console1">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console1"></textarea></p>
<div id="pyodide_div1"></div>
<div id="mpl_output1"></div>
<div id="brython_div1"></div>
<hr/>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button></p>
<!-- Editor 2 -->
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run2">Run</button> <button id="kw_output2">Output</button> <button id="kw_clear_console2">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console2"></textarea></p>
<div id="pyodide_div2"></div>
<div id="mpl_output2"></div>
<div id="brython_div2"></div>
<p>
<script>
function getUrlParam(key) {
  return new URLSearchParams(window.location.search).get(key);
}
function updateUrlParam(key, value) {
  const url = new URL(window.location);
  url.searchParams.set(key, value);
  window.history.replaceState({}, "", url);
}

let pyodide, editor1, editor2;

document.addEventListener("DOMContentLoaded", async () => {
  editor1 = ace.edit("kw_editor1");
  editor1.setTheme("ace/theme/chrome");
  editor1.session.setMode("ace/mode/python");

  editor2 = ace.edit("kw_editor2");
  editor2.setTheme("ace/theme/chrome");
  editor2.session.setMode("ace/mode/python");

  pyodide = await loadPyodide();
  await pyodide.loadPackage(["numpy", "scipy", "matplotlib", "micropip"]);

  // 定義 hello() 模組
  const code = `
def hello():
    print("Hello from custom module!")
`;
  pyodide.runPython(code);

  const GIST_ADD1TO100 =
    "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/" +
    "c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py";
  const NUMPY_ODE =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "98d582539545b3c9fbfa35dd3e605c506367618e/pyodide_ode_ex1.py";
  const PYODIDE_ROBOT_ANIMATION =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "f3d75d08f2b90f4470342e91ee1e5c36b5f950bf/pyodide_robot_ex1.py";
  const FREE_WALK = 
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" + "d1659628afe5d36a026ef305dc639f6be4c9f608/pyodide_robot_ex3.py"

  const src = getUrlParam("src");
  if (src === PYODIDE_ROBOT_ANIMATION) {
    const robotCode = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(robotCode, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  } else {
    const initialCode = await fetchCode(src || GIST_ADD1TO100);
    editor1.setValue(initialCode, -1);
    runPyodide(editor1, "kw_console1", "brython_div1");
  }

  editor2.setValue("", -1);

  document.getElementById("version").onclick = () => {
    const vcode = `
import pyodide
import sys
import matplotlib
import numpy
import scipy
print("Pyodide version:", pyodide.__version__)
print("Python version :", sys.version)
print("matplotlib version:", matplotlib.__version__)
print("numpy version:", numpy.__version__)
print("scipy version:", scipy.__version__)
`;
    editor1.setValue(vcode, -1);
    updateUrlParam("src", "inline_version");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("hello_button").onclick = () => {
    editor1.setValue("hello()", -1);
    updateUrlParam("src", "inline_hello");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor1.setValue(c, -1);
    updateUrlParam("src", GIST_ADD1TO100);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("numpy_ode").onclick = async () => {
    const c = await fetchCode(NUMPY_ODE);
    editor1.setValue(c, -1);
    updateUrlParam("src", NUMPY_ODE);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("robot1").onclick = async () => {
    const rc = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(rc, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("free_walk").onclick = async () => {
    const rc = await fetchCode(FREE_WALK);
    editor1.setValue(rc, -1);
    updateUrlParam("src", FREE_WALK);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100part2").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor2.setValue(c, -1);
    runPyodide(editor2, "kw_console2", "brython_div2");
  };

  document.getElementById("kw_run1").onclick = () =>
    runPyodide(editor1, "kw_console1", "brython_div1");
  document.getElementById("kw_run2").onclick = () =>
    runPyodide(editor2, "kw_console2", "brython_div2");
  document.getElementById("kw_clear_console1").onclick = () =>
    clearOutput("kw_console1", "brython_div1");
  document.getElementById("kw_clear_console2").onclick = () =>
    clearOutput("kw_console2", "brython_div2");
});

// 處理兩個 Output 列數
  document.getElementById("kw_output1").onclick = () => {
    const ta = document.getElementById("kw_console1");
    ta.rows = "15";
    ta.cols = "70";
    ta.scrollTop = 0;
  };
  document.getElementById("kw_output2").onclick = () => {
    const ta = document.getElementById("kw_console2");
    ta.rows = "15";
    ta.cols = "70";
    ta.scrollTop = 0;
  };

async function fetchCode(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`載入失敗 ${r.status}`);
  return await r.text();
}

function clearOutput(consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";
}

async function runPyodide(editor, consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";

  await pyodide.runPythonAsync(`
import sys
class JsWriter:
  def write(self, s):
    from js import document
    ta = document.getElementById("${consoleId}")
    ta.value += s
    ta.scrollTop = ta.scrollHeight
sys.stdout = JsWriter()
sys.stderr = JsWriter()
`);

  try {
    await pyodide.runPythonAsync(editor.getValue());
  } catch (e) {
    document.getElementById(consoleId).value += "\n錯誤：" + e.toString();
  }
}
</script>
</p>
<h2>Pyodide_ex</h2>
<p><a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/f3d75d08f2b90f4470342e91ee1e5c36b5f950bf/pyodide_robot_ex1.py">Pyodide 機器人巡邏</a> - 由於網頁載入場景圍牆與 Pyodide 執行機器人行走模擬的速度差異，機器人巡邏畫面的圍牆無法及時顯示。</p>
<p>經過場景圍牆多次 (目前為 3 次) 載入 (必須配合瀏覽器 Client 端執行速度與網路傳輸速度進行調整)，<a href="https://mde.tw/cp2025/content/Pyodide.html?src=https%3A%2F%2Fgist.githubusercontent.com%2Fmdecycu%2Fec4bb35dd0769e7a83d2a9fa57878a67%2Fraw%2Ff3d75d08f2b90f4470342e91ee1e5c36b5f950bf%2Fpyodide_robot_ex1.py">Pyodide 機器人巡邏2</a> 可以正確載入圍牆圖檔。</p>
<p>Pyodide 導入客製化模組:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">const code = `
# 定義一個模組內容
def hello():
    print("Hello from custom module!")
`;
pyodide.runPython(code);
</pre>
<p><a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/3ed6869dcd7312254513ca507de17945e15a9b6f/box_max_volume_short.py">Volume_max_pyodide_de_short.py</a></p>
<p><a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/3ed6869dcd7312254513ca507de17945e15a9b6f/box_volume_max_pyodide_de.py">Volume_max_pyodide_de.py</a></p>
<p></p>
<h2>Pyodide2</h2>
<p>Pyodide2 在頁面中導入 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/ff833d14181c7e270d37432aa8589f5ecf00e383/robot.py">robot.py</a> (註解版: <a href="/downloads/pyodide_robot_commented.py">pyodide_robot_commented.py</a>) 後，可以直接在頁面編輯器中，直接利用 walk() 與 turn_left() 兩個方法，引導<a href="https://mde.tw/cp2025/content/Pyodide2.html?src=https%3A%2F%2Fgist.githubusercontent.com%2Fmdecycu%2Fec4bb35dd0769e7a83d2a9fa57878a67%2Fraw%2Fff833d14181c7e270d37432aa8589f5ecf00e383%2Fpyodide_walk_around2.py">機器人前行與左轉</a>。也可以在編輯器中自行<a href="https://mde.tw/cp2025/content/Pyodide2.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py">定義右轉方法</a>，賦予機器人更多功能。</p>
<p>
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
</p>
<p><button id="version">version</button> <button id="hello_button">hello</button> <button id="add1to100">1 add to 100</button> <button id="robot1">機器人巡邏</button> <button id="free_walk">自由行</button> <button id="numpy_ode">numpy_ode</button></p>
<!-- Ace Editor Scripts -->
<p>
<script src="/static/ace/FileSaver.min.js"></script>
<script src="/static/ace/filereader.js"></script>
<script src="/static/ace/ace.js"></script>
<script src="/static/ace/ext-language_tools.js"></script>
<script src="/static/ace/mode-python.js"></script>
<script src="/static/ace/snippets/python.js"></script>
</p>
<!-- Editor 1 -->
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run1">Run</button> <button id="kw_output1">Output</button> <button id="kw_clear_console1">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console1"></textarea></p>
<div id="pyodide_div1"></div>
<div id="mpl_output1"></div>
<div id="brython_div1"></div>
<hr/>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button></p>
<!-- Editor 2 -->
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run2">Run</button> <button id="kw_output2">Output</button> <button id="kw_clear_console2">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console2"></textarea></p>
<div id="pyodide_div2"></div>
<div id="mpl_output2"></div>
<div id="brython_div2"></div>
<p>
<script>
function getUrlParam(key) {
  return new URLSearchParams(window.location.search).get(key);
}
function updateUrlParam(key, value) {
  const url = new URL(window.location);
  url.searchParams.set(key, value);
  window.history.replaceState({}, "", url);
}

let pyodide, editor1, editor2;

// 新增：把 robot.py 寫入 pyodide FS
async function loadRobotModule() {
  const robotUrl = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/4b94533a86b41ed8905cbb2d2bcae4e21a3e7410/robot.py";
  const r = await fetch(robotUrl);
  if (!r.ok) throw new Error(`載入 robot.py 失敗: ${r.status}`);
  const code = await r.text();
  pyodide.FS.writeFile("/robot.py", code);
  pyodide.runPython(`import sys; sys.path.append("/")`);  // 加入根目錄到 sys.path
}

document.addEventListener("DOMContentLoaded", async () => {
  editor1 = ace.edit("kw_editor1");
  editor1.setTheme("ace/theme/chrome");
  editor1.session.setMode("ace/mode/python");

  editor2 = ace.edit("kw_editor2");
  editor2.setTheme("ace/theme/chrome");
  editor2.session.setMode("ace/mode/python");

  pyodide = await loadPyodide();
  await pyodide.loadPackage(["numpy", "scipy", "matplotlib", "micropip"]);

  // 預先載入 robot.py
  await loadRobotModule();

  // 你現有的 hello() 定義
  const code = `
def hello():
    print("Hello from custom module!")
`;
  pyodide.runPython(code);

  // 這是你之前其他按鈕用的 Gist 連結
  const GIST_ADD1TO100 =
    "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/" +
    "c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py";
  const NUMPY_ODE =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "98d582539545b3c9fbfa35dd3e605c506367618e/pyodide_ode_ex1.py";
  const PYODIDE_ROBOT_ANIMATION =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "ff833d14181c7e270d37432aa8589f5ecf00e383/pyodide_walk_around2.py";
  const FREE_WALK = 
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" + "2a66dceb4a1dbdd0c384d4d17453f1e4f03f2493/pyodide_free_walk2.py"

  // 預設載入 GIST_ADD1TO100（或 URL 參數決定）
  const src = getUrlParam("src");
  if (src === PYODIDE_ROBOT_ANIMATION) {
    const robotCode = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(robotCode, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  } else {
    const initialCode = await fetchCode(src || GIST_ADD1TO100);
    editor1.setValue(initialCode, -1);
    runPyodide(editor1, "kw_console1", "brython_div1");
  }

  editor2.setValue("", -1);

  // 按鈕事件
  document.getElementById("version").onclick = () => {
    const vcode = `
import pyodide
import sys
import matplotlib
import numpy
import scipy
print("Pyodide version:", pyodide.__version__)
print("Python version :", sys.version)
print("matplotlib version:", matplotlib.__version__)
print("numpy version:", numpy.__version__)
print("scipy version:", scipy.__version__)
`;
    editor1.setValue(vcode, -1);
    updateUrlParam("src", "inline_version");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("hello_button").onclick = () => {
    editor1.setValue("hello()", -1);
    updateUrlParam("src", "inline_hello");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor1.setValue(c, -1);
    updateUrlParam("src", GIST_ADD1TO100);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("numpy_ode").onclick = async () => {
    const c = await fetchCode(NUMPY_ODE);
    editor1.setValue(c, -1);
    updateUrlParam("src", NUMPY_ODE);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("robot1").onclick = async () => {
    const rc = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(rc, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("free_walk").onclick = async () => {
    const rc = await fetchCode(FREE_WALK);
    editor1.setValue(rc, -1);
    updateUrlParam("src", FREE_WALK);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100part2").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor2.setValue(c, -1);
    runPyodide(editor2, "kw_console2", "brython_div2");
  };

  document.getElementById("kw_run1").onclick = () =>
    runPyodide(editor1, "kw_console1", "brython_div1");
  document.getElementById("kw_run2").onclick = () =>
    runPyodide(editor2, "kw_console2", "brython_div2");
  document.getElementById("kw_clear_console1").onclick = () =>
    clearOutput("kw_console1", "brython_div1");
  document.getElementById("kw_clear_console2").onclick = () =>
    clearOutput("kw_console2", "brython_div2");
});

// 調整 output textarea 行數
document.getElementById("kw_output1").onclick = () => {
  const ta = document.getElementById("kw_console1");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};
document.getElementById("kw_output2").onclick = () => {
  const ta = document.getElementById("kw_console2");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};

async function fetchCode(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`載入失敗 ${r.status}`);
  return await r.text();
}

function clearOutput(consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";
}

async function runPyodide(editor, consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";

  await pyodide.runPythonAsync(`
import sys
class JsWriter:
  def write(self, s):
    from js import document
    ta = document.getElementById("${consoleId}")
    ta.value += s
    ta.scrollTop = ta.scrollHeight
sys.stdout = JsWriter()
sys.stderr = JsWriter()
`);

  try {
    await pyodide.runPythonAsync(editor.getValue());
  } catch (e) {
    document.getElementById(consoleId).value += "\\n錯誤：" + e.toString();
  }
}
</script>
</p>
<h3>robot.py</h3>
<p><a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/ff833d14181c7e270d37432aa8589f5ecf00e383/robot.py">robot.py</a></p>
<p>第一段：模組匯入與常數定義</p>
<p>js 是 Brython 提供的 JS-Python 橋接模組，可直接操作 JavaScript DOM。<br/><br/>asyncio 是 Python 的非同步處理模組，用來讓動畫非同步進行。<br/><br/>CELL_SIZE 設定地圖中每個格子的大小（40px × 40px）。<br/><br/>WALL_THICKNESS 是用於繪製牆壁的線條厚度。<br/><br/>IMG_PATH 是儲存所有圖片的伺服器路徑（用於載入牆壁與機器人圖）。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import js, asyncio

# 每個格子的像素寬度
CELL_SIZE = 40

# 牆壁的厚度（像素）
WALL_THICKNESS = 6

# 圖片資源的網址前綴
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"
</pre>
<p>第二段：World 類別 – 建立世界與地圖圖層</p>
<p>World 類負責建立整個地圖畫面，並初始化所需的畫布圖層。<br/><br/>_image_cache 是類別層級變數，用來快取圖片物件。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class World:
    _image_cache = {}  # 用來暫存載入過的圖片，避免重複下載

    def __init__(self, width, height):
        self.width = width     # 地圖寬（幾格）
        self.height = height   # 地圖高（幾格）
        self.layers = self._create_layers()  # 建立四個 canvas 圖層
        self._init_html()      # 將圖層與控制按鈕加到 HTML 畫面
</pre>
<p>第三段：建立圖層</p>
<p>這些圖層都是 canvas 元素，彼此重疊在一起，依序繪製地圖。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _create_layers(self):
        return {
            "grid": js.document.createElement("canvas"),    # 網格底圖
            "walls": js.document.createElement("canvas"),   # 牆壁
            "objects": js.document.createElement("canvas"), # 痕跡/物件
            "robots": js.document.createElement("canvas"),  # 機器人
        }
</pre>
<p>第四段：初始化 HTML 結構</p>
<p>建立一個 container 容器，設定為相對定位。<br/><br/>將四層 canvas 疊放進容器中，每層用不同的 zIndex 疊層排序。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _init_html(self):
        container = js.document.createElement("div")
        container.style.position = "relative"
        container.style.width = f"{self.width * CELL_SIZE}px"
        container.style.height = f"{self.height * CELL_SIZE}px"

        for z, canvas in enumerate(self.layers.values()):
            canvas.width = self.width * CELL_SIZE
            canvas.height = self.height * CELL_SIZE
            canvas.style.position = "absolute"
            canvas.style.top = "0px"
            canvas.style.left = "0px"
            canvas.style.zIndex = str(z)
            container.appendChild(canvas)
</pre>
<p>第五段：建立控制按鈕並加入畫面</p>
<p>建立兩個按鈕：「前進」與「左轉」。<br/><br/>設定美觀的樣式（內邊距、字體大小等）。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">        button_container = js.document.createElement("div")
        button_container.style.marginTop = "10px"
        button_container.style.textAlign = "center"

        move_button = js.document.createElement("button")
        move_button.innerHTML = "Move Forward"
        move_button.style.margin = "5px"
        move_button.style.padding = "10px 20px"
        move_button.style.fontSize = "16px"
        button_container.appendChild(move_button)

        turn_button = js.document.createElement("button")
        turn_button.innerHTML = "Turn Left"
        turn_button.style.margin = "5px"
        turn_button.style.padding = "10px 20px"
        turn_button.style.fontSize = "16px"
        button_container.appendChild(turn_button)
</pre>
<p> 第六段：掛載進 HTML 與按鈕綁定</p>
<p>將畫面掛載到 HTML 中的 brython_div1 元素內。<br/><br/>同時記錄兩個按鈕到 self.move_button、self.turn_button 屬性，以便之後綁定事件</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">        brython_div = js.document.getElementById("brython_div1")
        if not brython_div:
            raise RuntimeError("🚨 'brython_div1' element not found in HTML!")
        brython_div.innerHTML = ""
        brython_div.appendChild(container)
        brython_div.appendChild(button_container)

        self.move_button = move_button
        self.turn_button = turn_button
</pre>
<p>第七段：繪製地圖網格線（grid）</p>
<p>這段程式會畫出地圖的格線，形成棋盤狀的網格。<br/><br/>每格大小為 CELL_SIZE = 40 像素。<br/><br/>格線只是視覺輔助，沒有碰撞作用。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _draw_grid(self):
        ctx = self.layers["grid"].getContext("2d")  # 取得網格圖層的繪圖上下文
        ctx.strokeStyle = "#cccccc"  # 設定線條顏色為淡灰色

        # 垂直線（每列格線）
        for i in range(self.width + 1):
            ctx.beginPath()
            ctx.moveTo(i * CELL_SIZE, 0)
            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)
            ctx.stroke()

        # 水平線（每欄格線）
        for j in range(self.height + 1):
            ctx.beginPath()
            ctx.moveTo(0, j * CELL_SIZE)
            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)
            ctx.stroke()
</pre>
<p>第八段：通用繪圖函式 _draw_image()</p>
<p>此函式負責畫圖片在指定格子位置。<br/><br/>需要傳入：<br/><br/>    ctx: 要繪製的畫布上下文。<br/><br/>    img_key: 要畫的圖片鍵（例如 "blue_robot_e"）。<br/><br/>    (x, y): 要畫在哪個格子（以地圖邏輯座標為主）。<br/><br/>    (w, h): 圖片的寬與高。<br/><br/>會自動調整畫面位置，將 y 軸上下反轉，使原點在左下角。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _draw_image(self, ctx, img_key, x, y, w, h, offset_x=0, offset_y=0):
        img = World._image_cache.get(img_key)
        if img and img.complete and img.naturalWidth &gt; 0:
            px = x * CELL_SIZE + offset_x
            py = (self.height - 1 - y) * CELL_SIZE + offset_y
            ctx.drawImage(img, px, py, w, h)
            return True
        else:
            print(f"⚠️ Image '{img_key}' not ready for drawing.")
            return False
</pre>
<p>第九段：繪製牆壁 _draw_walls()</p>
<p>這段會將四周的「邊界牆」畫出來。<br/><br/>利用 _draw_image 畫出 north.png 與 east.png。<br/><br/>offset_x / offset_y 用來對齊圖片位置（不會蓋到格子內）。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def _draw_walls(self):
        ctx = self.layers["walls"].getContext("2d")
        ctx.clearRect(0, 0, self.width * CELL_SIZE, self.height * CELL_SIZE)
        success = True

        # 繪製上下兩排的北牆（頂部與底部）
        for x in range(self.width):
            success &amp;= self._draw_image(ctx, "north", x, self.height - 1, CELL_SIZE, WALL_THICKNESS, offset_y=0)
            success &amp;= self._draw_image(ctx, "north", x, 0, CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)

        # 繪製左右兩側的東牆（左邊與右邊）
        for y in range(self.height):
            success &amp;= self._draw_image(ctx, "east", 0, y, WALL_THICKNESS, CELL_SIZE, offset_x=0)
            success &amp;= self._draw_image(ctx, "east", self.width - 1, y, WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)

        return success
</pre>
<p>第十段：預先載入圖片 _preload_images()</p>
<p>此函式會載入所有需要用到的圖片（牆壁與機器人朝向圖）。<br/><br/>利用 Promise 建立圖片載入完成的非同步事件，確保載入成功。<br/><br/>透過 await js.await_promise(js.Promise.all(...)) 等待所有圖片載入完畢。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def _preload_images(self):
        image_files = {
            "blue_robot_e": "blue_robot_e.png",
            "blue_robot_n": "blue_robot_n.png",
            "blue_robot_w": "blue_robot_w.png",
            "blue_robot_s": "blue_robot_s.png",
            "north": "north.png",
            "east": "east.png",
        }

        promises = []
        for key, filename in image_files.items():
            if key in World._image_cache and World._image_cache[key].complete:
                continue

            img = js.document.createElement("img")
            img.crossOrigin = "Anonymous"
            img.src = IMG_PATH + filename
            World._image_cache[key] = img

            def make_promise(img_element):
                def executor(resolve, reject):
                    def on_load(event):
                        img_element.removeEventListener("load", on_load)
                        img_element.removeEventListener("error", on_error)
                        resolve(img_element)
                    def on_error(event):
                        img_element.removeEventListener("load", on_load)
                        img_element.removeEventListener("error", on_error)
                        reject(f"Failed to load image: {img_element.src}")
                    img_element.addEventListener("load", on_load)
                    img_element.addEventListener("error", on_error)
                    if img_element.complete and img_element.naturalWidth &gt; 0:
                        resolve(img_element)
                return js.Promise.new(executor)

            promises.append(make_promise(img))

        if not promises:
            return True
        try:
            await js.await_promise(js.Promise.all(promises))
            return True
        except Exception as e:
            print(f"🚨 Error during image preloading: {str(e)}")
            return False
</pre>
<p>第十一段：初始化地圖與資源 setup()</p>
<p>setup() 是建構完世界後必須呼叫的初始化函式。<br/><br/>包含資源載入、地圖格線與牆壁的繪製。<br/><br/>使用 asyncio.sleep(0) 是一種「讓出主控權給瀏覽器」的技巧，避免卡住畫面。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def setup(self):
        # 嘗試三次載入圖片資源，若載入成功則跳出迴圈
        for _ in range(3):
            if await self._preload_images():
                break
            await asyncio.sleep(0.5)  # 等待 0.5 秒後再試
        else:
            print("🚨 Failed to preload images after retries.")
            return False

        await asyncio.sleep(0)  # 放棄當前事件迴圈執行權，確保 UI 有機會更新

        self._draw_grid()  # 繪製底層的網格

        # 嘗試三次繪製牆壁，等待圖片載入完成
        for _ in range(3):
            if await self._draw_walls():
                break
            await asyncio.sleep(0.5)
        else:
            print("🚨 Failed to draw walls after retries.")
            return False

        # 最後確認機器人朝向東的圖片是否可用
        robot_img_key = "blue_robot_e"
        if not (World._image_cache.get(robot_img_key) and World._image_cache[robot_img_key].complete):
            print(f"🚨 Robot image '{robot_img_key}' still not ready after setup!")
            return False

        return True  # 所有步驟成功後回傳 True
</pre>
<p>第十二段：機器人類別 Robot</p>
<p>每個 Robot 物件都有座標與面向，並能畫出自己與移動的軌跡。<br/><br/>傳入 world 是為了能取得地圖的畫布資訊。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class Robot:
    def __init__(self, world, x, y):
        self.world = world
        self.x = x - 1  # 將人類習慣的 1-index 轉成 0-index
        self.y = y - 1
        self.facing = "E"  # 預設朝東（右邊）
        self._facing_order = ["E", "N", "W", "S"]  # 左轉時的順序

        self.robot_ctx = world.layers["robots"].getContext("2d")   # 機器人圖層
        self.trace_ctx = world.layers["objects"].getContext("2d")  # 移動軌跡圖層

        self._draw_robot()  # 初始畫上機器人
</pre>
<p>_robot_image_key()：依面向回傳圖片鍵</p>
<p>根據面向回傳對應的圖片鍵，例如 <code data-end="1939" data-start="1936">E</code> 會回傳 <code data-end="1960" data-start="1944">"blue_robot_e"</code>。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _robot_image_key(self):
        return f"blue_robot_{self.facing.lower()}"
</pre>
<p>_draw_robot()：畫出機器人圖像</p>
<p>先清除原圖，避免留下殘影，再畫上新的機器人圖像。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _draw_robot(self):
        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)
        self.world._draw_image(self.robot_ctx, self._robot_image_key(), self.x, self.y, CELL_SIZE, CELL_SIZE)
</pre>
<p>_draw_trace()：畫出移動路徑</p>
<p>此方法畫出機器人從起點到終點的直線軌跡。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _draw_trace(self, from_x, from_y, to_x, to_y):
        ctx = self.trace_ctx
        ctx.strokeStyle = "#d33"  # 紅色線條
        ctx.lineWidth = 2
        ctx.beginPath()
        fx = from_x * CELL_SIZE + CELL_SIZE / 2
        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2
        tx = to_x * CELL_SIZE + CELL_SIZE / 2
        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2
        ctx.moveTo(fx, fy)
        ctx.lineTo(tx, ty)
        ctx.stroke()
</pre>
<p>第十三段：機器人行走與轉彎</p>
<p>walk(steps)：前進</p>
<p>根據面向方向更新位置，並畫出移動。<br/><br/>超出地圖邊界時停止。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def walk(self, steps=1):
        for _ in range(steps):
            from_x, from_y = self.x, self.y
            dx, dy = 0, 0
            if self.facing == "E": dx = 1
            elif self.facing == "W": dx = -1
            elif self.facing == "N": dy = 1
            elif self.facing == "S": dy = -1

            next_x = self.x + dx
            next_y = self.y + dy

            if 0 &lt;= next_x &lt; self.world.width and 0 &lt;= next_y &lt; self.world.height:
                self.x, self.y = next_x, next_y
                self._draw_trace(from_x, from_y, self.x, self.y)
                self._draw_robot()
                await asyncio.sleep(0.2)
            else:
                print("🚨 Hit a wall, stop moving!")
                break
</pre>
<p>turn_left()：左轉</p>
<p>從目前面向向左轉一格，更新圖片。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def turn_left(self):
        idx = self._facing_order.index(self.facing)
        self.facing = self._facing_order[(idx + 1) % 4]  # 循環轉向
        self._draw_robot()
        await asyncio.sleep(0.3)
</pre>
<p>第十四段：綁定控制 _bind_controls(robot)</p>
<p>定義一個私有方法，將控制行為綁定給特定 robot 實例。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def _bind_controls(robot: Robot):
</pre>
<p>鍵盤控制</p>
<p>設定 j → 前進，i → 左轉。<br/><br/>使用 asyncio.create_task() 以非同步方式執行，避免卡住主執行緒。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def handle_key(event):
        try:
            if event.key == 'j':
                asyncio.create_task(robot.walk(1))     # 按下 j 移動一步
            elif event.key == 'i':
                asyncio.create_task(robot.turn_left()) # 按下 i 左轉
        except Exception as e:
            print(f"🚨 Error in key handler: {e}")
</pre>
<p>按鈕點擊控制</p>
<p>這兩個函式綁定到 UI 裡的按鈕（前面 _init_html() 中定義的）。<br/><br/>功能與鍵盤控制一樣，只是透過滑鼠點擊。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def handle_move_button(event):
        try:
            asyncio.create_task(robot.walk(1))
        except Exception as e:
            print(f"🚨 Error in move button handler: {e}")

    def handle_turn_button(event):
        try:
            asyncio.create_task(robot.turn_left())
        except Exception as e:
            print(f"🚨 Error in turn button handler: {e}")
</pre>
<p>註冊事件到 JavaScript</p>
<p>將 handle_key() 註冊為全域 py_handle_key，讓 JavaScript 層級可以呼叫 Python。</p>
<p>將按鈕的點擊事件對應到 Python 定義的控制函式。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    js.window.py_handle_key = handle_key
    js.document.addEventListener('keydown', js.Function("event", "py_handle_key(event);"))
    js.window.py_handle_move_button = handle_move_button
    js.window.py_handle_turn_button = handle_turn_button
    robot.world.move_button.addEventListener('click', js.Function("event", "py_handle_move_button(event);"))
    robot.world.turn_button.addEventListener('click', js.Function("event", "py_handle_turn_button(event);"))</pre>
<p>第十五段：初始化並啟動 init()</p>
<p>提供一個使用者簡單快速初始化整個世界與機器人的介面。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def init(world_width=10, world_height=10, robot_x=1, robot_y=1):
</pre>
<p>包裝為非同步任務</p>
<p>這個包裝函式 async def _inner() 是用來實作內部非同步邏輯。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def _inner():
        world = World(world_width, world_height)  # 建立世界
        if not await world.setup():               # 等待世界初始化完成
            raise RuntimeError("World setup failed!")  # 若失敗則丟出錯誤

        robot = Robot(world, robot_x, robot_y)    # 建立機器人
        _bind_controls(robot)                     # 綁定控制事件
        return world, robot                       # 傳回 world 和 robot 物件
</pre>
<p>建立並啟動非同步任務</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    return asyncio.create_task(_inner())
</pre>
<p>回傳一個非同步任務（asyncio.Task），讓使用者可以這樣呼叫：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">world, robot = await init(10, 10, 1, 1)
</pre>
<p>等待 init() 的結果後，就可以直接控制 robot.walk() 或 robot.turn_left()。</p>
<h3>Example2</h3>
<p>自行定義機器人右轉的非同步執行函式:</p>
<p><a href="https://mde.tw/cp2025/content/Pyodide2.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py">執行 turn_right 程式</a>範例。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import robot
import asyncio

# 定義右轉的非同步函式
async def turn_right(bot):
    for _ in range(3):
        await bot.turn_left()

async def main():
    world, bot = await robot.init(10, 10, 1, 1)
    print("機器人開始行動")
    await bot.turn_left()
    await bot.walk(9)
    await turn_right(bot) 
    print("機器人完成行動")

# main() 讓出執行控制權，由頁面中的 even loop 決定何時執行 main()
await main()
</pre>
<h2>Pyodide3</h2>
<p>Pyodide3 則在 <a href="https://mde.tw/cp2025/content/Pyodide.html">Pyodide</a> 與 <a href="https://mde.tw/cp2025/content/Pyodide2.html">Pyodide2</a> 頁面架構下，進一步導入 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a>，在既有的水平圍牆 <a href="https://mde.tw/cp2025/reeborg/src/images/north.png">north.png</a> 與垂直圍牆 <a href="https://mde.tw/cp2025/reeborg/src/images/east.png">east.png</a> 檔案之外，加入 <a href="https://mde.tw/cp2025/reeborg/src/images/carrot.png">carrot.png</a>、<a href="https://mde.tw/cp2025/reeborg/src/images/grass.png">grass.png</a> 與 <a href="https://mde.tw/cp2025/reeborg/src/images/pale_grass.png">pale_grass.png</a> 等圖檔。並且擴充可從 URL 讀進 json 格式的 world 變數功能，以便製作出更多元的場景任務，要求機器人執行。</p>
<p>其中 src URL 變數，可以將網路上的機器人控制程式導入 Pyodide3 頁面外，world URL 變數則可以導入源自 <a href="https://mde.tw/reeborg">Reeborg</a> 機器人程式所設定的 json 格式場景。</p>
<p>由於 Reeborg 系統中的 png 圖檔均非透明背景，<a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 必須利用 HTML 中的 CANVAS，將關鍵的白色背景，以透明的方式顯示。</p>
<p>src URL 變數讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py">turn_right 程式</a>，而 world URL 變數則讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/43517f3f54a5ac24d55d5a5cf8d316e6db2f3b65/harvest2.json">harvest2.json</a>，執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/43517f3f54a5ac24d55d5a5cf8d316e6db2f3b65/harvest2.json">結果</a>。</p>
<p>讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/1b1c26eca7f5d772c6301bae865efaddb00a87bb/harvest3.json">harvest3.json</a>, 執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/harvest3.json">結果</a>。</p>
<p>
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
</p>
<p><button id="version">version</button> <button id="hello_button">hello</button> <button id="add1to100">1 add to 100</button> <button id="robot1">機器人巡邏</button> <button id="free_walk">自由行</button> <button id="numpy_ode">numpy_ode</button></p>
<!-- Ace Editor Scripts -->
<p>
<script src="/static/ace/FileSaver.min.js"></script>
<script src="/static/ace/filereader.js"></script>
<script src="/static/ace/ace.js"></script>
<script src="/static/ace/ext-language_tools.js"></script>
<script src="/static/ace/mode-python.js"></script>
<script src="/static/ace/snippets/python.js"></script>
</p>
<!-- Editor 1 -->
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run1">Run</button> <button id="kw_output1">Output</button> <button id="kw_clear_console1">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console1"></textarea></p>
<div id="pyodide_div1"></div>
<div id="mpl_output1"></div>
<div id="brython_div1"></div>
<hr/>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button></p>
<!-- Editor 2 -->
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run2">Run</button> <button id="kw_output2">Output</button> <button id="kw_clear_console2">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console2"></textarea></p>
<div id="pyodide_div2"></div>
<div id="mpl_output2"></div>
<div id="brython_div2"></div>
<p>
<script>
function getUrlParam(key) {
  return new URLSearchParams(window.location.search).get(key);
}
function updateUrlParam(key, value) {
  const url = new URL(window.location);
  url.searchParams.set(key, value);
  window.history.replaceState({}, "", url);
}

let pyodide, editor1, editor2;

// 新增：把 robot_w_world.py 寫入 pyodide FS
async function loadRobotModule() {
  const robotUrl = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py";
  const r = await fetch(robotUrl);
  if (!r.ok) throw new Error(`載入 robot.py 失敗: ${r.status}`);
  const code = await r.text();
  pyodide.FS.writeFile("/robot.py", code);
  pyodide.runPython(`import sys; sys.path.append("/")`);  // 加入根目錄到 sys.path
}

document.addEventListener("DOMContentLoaded", async () => {
  editor1 = ace.edit("kw_editor1");
  editor1.setTheme("ace/theme/chrome");
  editor1.session.setMode("ace/mode/python");

  editor2 = ace.edit("kw_editor2");
  editor2.setTheme("ace/theme/chrome");
  editor2.session.setMode("ace/mode/python");

  pyodide = await loadPyodide();
  await pyodide.loadPackage(["numpy", "scipy", "matplotlib", "micropip"]);

  // 預先載入 robot.py
  await loadRobotModule();

  // 你現有的 hello() 定義
  const code = `
def hello():
    print("Hello from custom module!")
`;
  pyodide.runPython(code);

  // 這是你之前其他按鈕用的 Gist 連結
  const GIST_ADD1TO100 =
    "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/" +
    "c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py";
  const NUMPY_ODE =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "98d582539545b3c9fbfa35dd3e605c506367618e/pyodide_ode_ex1.py";
  const PYODIDE_ROBOT_ANIMATION =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "ff833d14181c7e270d37432aa8589f5ecf00e383/pyodide_walk_around2.py";
  const FREE_WALK = 
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" + "2a66dceb4a1dbdd0c384d4d17453f1e4f03f2493/pyodide_free_walk2.py"

  // 預設載入 GIST_ADD1TO100（或 URL 參數決定）
  const src = getUrlParam("src");
  if (src === PYODIDE_ROBOT_ANIMATION) {
    const robotCode = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(robotCode, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  } else {
    const initialCode = await fetchCode(src || GIST_ADD1TO100);
    editor1.setValue(initialCode, -1);
    runPyodide(editor1, "kw_console1", "brython_div1");
  }

  editor2.setValue("", -1);

  // 按鈕事件
  document.getElementById("version").onclick = () => {
    const vcode = `
import pyodide
import sys
import matplotlib
import numpy
import scipy
print("Pyodide version:", pyodide.__version__)
print("Python version :", sys.version)
print("matplotlib version:", matplotlib.__version__)
print("numpy version:", numpy.__version__)
print("scipy version:", scipy.__version__)
`;
    editor1.setValue(vcode, -1);
    updateUrlParam("src", "inline_version");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("hello_button").onclick = () => {
    editor1.setValue("hello()", -1);
    updateUrlParam("src", "inline_hello");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor1.setValue(c, -1);
    updateUrlParam("src", GIST_ADD1TO100);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("numpy_ode").onclick = async () => {
    const c = await fetchCode(NUMPY_ODE);
    editor1.setValue(c, -1);
    updateUrlParam("src", NUMPY_ODE);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("robot1").onclick = async () => {
    const rc = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(rc, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("free_walk").onclick = async () => {
    const rc = await fetchCode(FREE_WALK);
    editor1.setValue(rc, -1);
    updateUrlParam("src", FREE_WALK);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100part2").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor2.setValue(c, -1);
    runPyodide(editor2, "kw_console2", "brython_div2");
  };

  document.getElementById("kw_run1").onclick = () =>
    runPyodide(editor1, "kw_console1", "brython_div1");
  document.getElementById("kw_run2").onclick = () =>
    runPyodide(editor2, "kw_console2", "brython_div2");
  document.getElementById("kw_clear_console1").onclick = () =>
    clearOutput("kw_console1", "brython_div1");
  document.getElementById("kw_clear_console2").onclick = () =>
    clearOutput("kw_console2", "brython_div2");
});

// 調整 output textarea 行數
document.getElementById("kw_output1").onclick = () => {
  const ta = document.getElementById("kw_console1");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};
document.getElementById("kw_output2").onclick = () => {
  const ta = document.getElementById("kw_console2");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};

async function fetchCode(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`載入失敗 ${r.status}`);
  return await r.text();
}

function clearOutput(consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";
}

async function runPyodide(editor, consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";

  await pyodide.runPythonAsync(`
import sys
class JsWriter:
  def write(self, s):
    from js import document
    ta = document.getElementById("${consoleId}")
    ta.value += s
    ta.scrollTop = ta.scrollHeight
sys.stdout = JsWriter()
sys.stderr = JsWriter()
`);

  try {
    await pyodide.runPythonAsync(editor.getValue());
  } catch (e) {
    document.getElementById(consoleId).value += "\\n錯誤：" + e.toString();
  }
}
</script>
</p>
<h3>png_files</h3>
<p>利用 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 將 png 圖檔實踐「關鍵色透明」:<br/><br/>作法是在程式碼中額外添加像素處理的邏輯。Canvas 的 drawImage 方法本身不會自動識別並跳過特定顏色的像素，所以我們必須手動介入。<br/><br/>處理方法:<br/><br/>要讓 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 實現這個功能，必須修改 _draw_image 方法，或者在圖片載入後進行預處理。最直接的方法是在繪製數字圖片時，讀取其像素數據，並將特定顏色（例如白色）的像素的 Alpha 值設置為 0。<br/><br/>這會涉及以下步驟：<br/><br/>    取得圖片像素資料： 將圖片繪製到一個臨時的、看不見的 Canvas 上。<br/><br/>    讀進所有像素： 讀取這個臨時 Canvas 的像素資料。<br/><br/>    修改像素的 Alpha 值： 檢查每個像素的 RGB 值，如果它符合預設的「關鍵色」（例如，純白色 (255, 255, 255)），就將其 Alpha (透明度) 值設為 0。<br/><br/>    將修改後的像素資料放回： 將修改後的像素資料重新放回臨時 Canvas。<br/><br/>    繪製臨時 Canvas： 最後，將這個處理過的臨時 Canvas 繪製到我們實際要顯示的圖層上。<br/><br/>缺點與考量:<br/><br/>    性能影響： 像素級的處理是相對耗費資源的，特別是當有很多數字需要顯示時。這可能會導致動畫或初始加載時出現輕微的延遲。<br/><br/>    複雜性增加： 程式碼會變得更複雜，需要處理 Canvas API 的 getImageData 和 putImageData 方法。<br/><br/>    關鍵色選擇： 您需要確定一個所有數字圖片背景都一致的「關鍵色」。如果有些數字圖片背景是白色，有些是淺灰色，這個方法就會失效。</p>
<h3>Harvest</h3>
<p><a href="https://mde.tw/cp2025/content/Pyodide3.html">Pyodide3</a> 在頁面中導入 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 後，可以透過 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/a1de47ae2a2c941d6abe945bd58ae79ba38be8c6/pyodide3_harvest_ex1.py">pyodide3_harvest_ex1.py</a> 繼承 robot 物件，加入農作物採收功能。</p>
<p>但因為 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 版本中的 trace 繪製圖層並未獨立，除了採收農作物之後的座標背景會從 pale_grass.png 置換為 grass.png 外，農作物採收後的座標畫面刷新會一併將之前的機器人行走路徑刪除，因此後續版本必須將所有不同屬性的圖像，以各自的獨立圖層進行繪製，才不會互相影響下，產生錯誤的機器人農作物採收模擬。</p>
<p>在 Pyodide3 執行 <a href="/downloads/pyodide3_harvest_ex1.py">pyodide3_harvest_ex1.py</a>，執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/f1663c2de7f7f7a7fe24723c196810642865822f/pyodide3_harvest_ex1.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/harvest3.json">結果</a>。</p>
<p></p>